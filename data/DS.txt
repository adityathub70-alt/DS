1. Insertion in an array
2. Deletion from an array
3. Merging 2 arrays
4. Sum of Array elements
5. Search an element in an array
6. Find maximum in an Array
7. MIN To MAX
8. Leader of an Array
9. Maximum Subarray Sum
10. Linked List - Concept
11. Insertion in Linked List
12. Linked List - Insertion at end
13. Linked List - Insertion at k-th position
14. Optimal insertion at the end
15. Reverse a Linked list
16. Reverse a Linked list II
17. Remove Duplicate Data
18. Delete from front
19. Delete from any position
20. Insertion at end in Circular Linked List
21. Deletion in Circular Linked List
22. Insertion in Doubly Linked List
23. Deletion - Doubly Linked List
24. Practice - Josephus Problem
25. Practice - Music Player
26. Push and Pop
27. Peek, isEmpty, isFull
28. Implement Stack using Arrays
29. Convert Decimal to Binary
30. Valid Parenthesis
31. Evaluate Expression
32. Transform the Expression
33. isEmpty, isFull, functions of Queue
34. Enqueue and Dequeue Functions
35. Queue - Print Numbers with a Gi
36. Queue - To do list
37. Stone Pile
38. Practice problem - Necklace
39. Infix to Postfix
40. String Palindrome using Stack
41. Check Palindrome using Queue
42. Implementation - Adjacency Matrix
43. Implementation - Adjacency List
44. Depth First Search
45. Breadth First Search
46. Count number of leaf nodes
47. Height of the tree
48. Nodes at Kth Level
49. Tree Path Sum
50. Neighbours of node
51. Subtree Sum
52. Diameter of the tree
53. LCA of two nodes
54. Distance between two nodes
55. Kth ancestor of the node
56. Largest value at each level
57. Distinct colors in subtrees
58. Minimum time to collect all coins
59. Implementation - Binary Tree
60. PreOrder Traversal
61. PostOrder Traversal
62. InOrder Traversal
63. Height of Binary Tree
64. Height Balanced Binary Tree
65. Identical Binary Trees
66. Mirror Tree
67. Level Order Traversal
68. ZigZag Traversal
69. Boundary of the Binary Tree
70. Top view of the Binary Tree
71. Minimum Depth of Binary Tree
72. Construct Binary Tree
73. Sum of deepest leaves
74. Find the Subtree
75. Reconstruct the Tree
76. Triplet LCA
77. Trees - Branch Sum
78. Paths with given sum
79. Implementation - Create BST
80. Search in BST
81. Print nodes in sorted order
82. Find maximum node in BST
83. Create BST from given sorted array
84. Min Difference in BST
85. Check for BST
86. Kth Largest Node in BST
87. Predecessor of a Node in BST
88. Delete a Node in BST
89. BST Two Sum
90. Recover the BST
91. LCA in the BST
92. Graph Implementation - Adjacency
93. Graph Implementation - Adjacency Matrix
94. DFS on Graph
95. BFS on Graph
96. Check Reachability
97. Chef Shortest Route
98. Minimum Distance Between Two Nodes
99. Algorithm description
100. Single Source Shortest Path
101. Priority Queue Approach
102. Single Source Shortest Path
103. Minimum Cost Walk
104. Planetary Path
105. Real life implementation
106. Linear Search in array
107. Linear Search in string
108. Miscellaneous Linear Search
109. Find Kth Character Position
110. Find smallest and largest numbers
111. Find Smallest Absolute Difference
112. Find Pairs Divisible Sum
113. Find Valid Pair
114. Sort three integer
115. Implementation of Bubble Sort
116. Complete the implementation
117. NGE
118. Complete the implementation
119. Complete the implementation
120. Merging
121. Complete the implementation
122. Complete the implementation
123. Complete the implementation
124. Frequency of each element in the array
125. Frequency of elements using Hashing
126. Count Beautiful Pairs
127. Hashing Function Example
128. Count Beautiful Pairs




1. Insertion in an array


#include <stdio.h>

int main() {
    int arr[100] = {2, 4, 6, 8, 10}; // Initial array
    int size = 5; // Current size of the array

    int newPosition = 2; // Index where you want to insert the new element
    int newElement = 7; // Element to be inserted

    // Shift elements to make space for the new element
    for (int i = size - 1; i >= newPosition; i--) {
        arr[i + 1] = arr[i];
    }

    // Insert the new element at the specified position
    arr[newPosition] = newElement;

    size++; // Update the size of the array

    // Print the updated array
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }

    return 0;
}



2. Deletion from an array


#include <stdio.h>

int main() {
    int arr[100] = {2, 4, 6, 8, 10};  // Initial array
    int size = 5;  // Current size of the array
    int positionToDelete = 2;  // Index of the element to delete

    // Update the code to shift elements to fill the gap left by the deleted element
    for (int i = positionToDelete; i < size - 1; i++) {
        arr[i] = arr[i + 1];  // Shift each element left by one position
    }

    // Update the size of the array
    size--;

    // Print the updated array
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}


3. Merging 2 arrays


#include <stdio.h>

int main() {
    int arr1[100] = {2, 4, 6};  // First array
    int size1 = 3;  // Size of the first array

    int arr2[100] = {8, 10, 12, 14};  // Second array
    int size2 = 4;  // Size of the second array

    // Create a new array to hold the merged elements
    int mergedSize = size1 + size2;  // Total size of the merged array
    int merged[mergedSize];  // New array to store the merged result

    // Copy elements from the first array
    int i;
    for (i = 0; i < size1; i++) {
        merged[i] = arr1[i];
    }

    // Copy elements from the second array
    for (int j = 0; j < size2; j++, i++) {
        merged[i] = arr2[j];
    }

    // Print the merged array
    for (int k = 0; k < mergedSize; k++) {
        printf("%d ", merged[k]);
    }
    printf("\n");

    return 0;
}


4. Sum of Array elements


#include <stdio.h>

int main() 

{


    int N;
    scanf("%d", &N);

    int A[N], sum = 0;

    for (int i = 0; i < N; i++) 

{


        scanf("%d", &A[i]);
        sum += A[i];
    

}

    printf("%d\n", sum);

    return 0;

}




5. Search an element in an array


#include <stdio.h>

int main() 

{


    int N, X;
    scanf("%d %d", &N, &X);

    int A[N];
    int found = 0;

    for (int i = 0; i < N; i++) 

{


        scanf("%d", &A[i]);
        if (A[i] == X) 

{


            found = 1;
        

}
    

}

    if (found) 

{


        printf("YES\n");
    

} else 

{


        printf("NO\n");
    

}

    return 0;

}



6.Find maximum in an Array


#include <stdio.h>

int main() 

{


    int T;
    scanf("%d", &T);

    while (T--) 

{


        int N;
        scanf("%d", &N);

        long long max_height = 0;  // Use long long for heights up to 10^9
        long long height;

        for (int i = 0; i < N; i++) 

{


            scanf("%lld", &height);
            if (height > max_height) 

{


                max_height = height;
            

}
        

}

        printf("%lld\n", max_height);
    

}

    return 0;

}


7. MIN To MAX


#include <stdio.h>

int main() {
    int T;
    scanf("%d", &T);

    while (T--) {
        int N;
        scanf("%d", &N);
        int A[100];
        int i, min = 101, count = 0;

        for (i = 0; i < N; i++) {
            scanf("%d", &A[i]);
            if (A[i] < min) {
                min = A[i];
            }
        }

        count = 0;
        for (i = 0; i < N; i++) {
            if (A[i] > min) {
                count++;
            }
        }

        printf("%d\n", count);
    }

    return 0;
}


8. Leader of an Array


#include <stdio.h>

int main() {
    int N;
    scanf("%d", &N);
    int A[100], leaders[100], i, count = 0;

    for (i = 0; i < N; i++) {
        scanf("%d", &A[i]);
    }

    int max_from_right = A[N - 1];
    leaders[count++] = max_from_right;

    for (i = N - 2; i >= 0; i--) {
        if (A[i] > max_from_right) {
            max_from_right = A[i];
            leaders[count++] = A[i];
        }
    }

    for (i = count - 1; i >= 0; i--) {
        printf("%d ", leaders[i]);
    }

    return 0;
}


9. Maximum Subarray Sum


#include <stdio.h>

int main() {
    int T;
    scanf("%d", &T);

    while (T--) {
        int N;
        scanf("%d", &N);
        long long A[100];
        for (int i = 0; i < N; i++) {
            scanf("%lld", &A[i]);
        }

        long long max_sum = A[0];
        long long current_sum = A[0];

        for (int i = 1; i < N; i++) {
            if (current_sum < 0) {
                current_sum = A[i];
            } else {
                current_sum += A[i];
            }

            if (current_sum > max_sum) {
                max_sum = current_sum;
            }
        }

        printf("%lld\n", max_sum);
    }

    return 0;
}


10. Linked List - Concept

#include <stdio.h>
#include <stdlib.h>
// Define a struct for the linked list node
struct Node {
    int value;
    struct Node* next;
};
int main() {
    // Creating head of the Linked list
    struct Node* head = (struct Node*)malloc(sizeof(struct Node));
    head->value = 1;
    head->next = NULL;
    printf("The value at head is %d\n", head->value);
    // Don’t forget to free memory allocated for the head node
    free(head);
    return 0;
}



11. Insertion in Linked List


#include <stdio.h>
#include <stdlib.h>

// Define a struct for the linked list node
struct Node {
    int value;
    struct Node* next;
};

// Define a struct for the linked list
struct LinkedList {
    struct Node* head;
};

// Function to insert a node at the front of the linked list
void insert_front(struct LinkedList* list, int value) {
    printf("Inserting %d\n", value);
    
    // Step 1: Create a new Node
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    if (new_node == NULL) {
        printf("Memory allocation failed\n");
        return;
    }
    new_node->value = value;
    
    // Step 2: Set next of new_node to the current head
    new_node->next = list->head;
    
    // Step 3: Set new_node as the head
    list->head = new_node;
}

// Function to get the value at the head of the linked list
int get_head_value(struct LinkedList* list) {
    if (list->head == NULL) {
        return -1;
    } else {
        return list->head->value;
    }
}

int main() {
    // Create an instance of LinkedList
    struct LinkedList list;
    list.head = NULL;
    
    insert_front(&list, 3);
    printf("The value at the head is: %d\n", get_head_value(&list));
    
    insert_front(&list, 2);
    printf("The value at the head is: %d\n", get_head_value(&list));
    
    return 0;
}


12. Linked List - Insertion at end


#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to insert a new node at the end of the list
void insertAtEnd(struct Node** head, int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;

    if (*head == NULL) {
        *head = newNode;
        return;
    }

    struct Node* temp = *head;
    while (temp->next != NULL) {
        temp = temp->next;
    }

    temp->next = newNode;
}

// Function to get the value of the last node
int getLastValue(struct Node* head) {
    struct Node* temp = head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    return temp->data;
}

// Main function to drive input/output
int main() {
    int n;
    scanf("%d", &n);

    struct Node* head = NULL;

    for (int i = 0; i < n; i++) {
        int value;
        scanf("%d", &value);
        insertAtEnd(&head, value);
        printf("%d ", getLastValue(head));
    }

    return 0;
}



13. Linked List - Insertion at k-th position 


void insertAfterK(LinkedList* list, int value, int k) {
    Node* newNode = createNode(value);
    Node* current = list->head;

    // If there are no nodes in the linked list
    // Set the new node as head and return
    if (current == NULL) {
        list->head = newNode;
        return;
    }

    // Iterate to the k-th node
    for (int i = 1; i < k; i++) {
        if (current->next == NULL) {
            // If k is larger than the number of nodes,
            // insert at the end
            current->next = newNode;
            return;
        }
        current = current->next;
    }

    // Set the next of newNode to next of current
    newNode->next = current->next;

    // Set the next of current to newNode
    current->next = newNode;
}


14. Optimal insertion at the end


typedef struct LinkedList {
    Node* head;
    Node* tail;
} LinkedList;

// Function to insert a node at the end of the linked list
void insertAtEnd(LinkedList* list, int value) {
    Node* newNode = createNode(value);
    // If there are no nodes in the linked list
    // Set the new node as head and tail
    if (list->head == NULL) {
        list->head = newNode;
        list->tail = newNode;
        return;
    }

    list->tail->next = newNode;
    list->tail = newNode;
}


15. Reverse a Linked list

#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

Node* insertAtEnd(Node* head, int value) {
    Node* newNode = createNode(value);
    if (head == NULL) return newNode;
    Node* temp = head;
    while (temp->next != NULL) temp = temp->next;
    temp->next = newNode;
    return head;
}

Node* reverseList(Node* head) {
    Node* prev = NULL;
    Node* curr = head;
    Node* next = NULL;
    while (curr != NULL) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

void printList(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%d", temp->data);
        if (temp->next != NULL) printf(" -> ");
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    int n, value;
    scanf("%d", &n);
    Node* head = NULL;
    for (int i = 0; i < n; i++) {
        scanf("%d", &value);
        head = insertAtEnd(head, value);
    }
    head = reverseList(head);
    printList(head);
    return 0;
}


15. Reverse a Linked list II

#include <stdio.h>
#include <stdlib.h>

// Define node structure
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Function to create new node
Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Function to insert at end
void insertAtEnd(Node** head, int value) {
    Node* newNode = createNode(value);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* temp = *head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
}

// Recursive function to reverse linked list
Node* reverseListRecursive(Node* head) {
    // Base case: empty list or single node
    if (head == NULL || head->next == NULL) {
        return head;
    }
    Node* newHead = reverseListRecursive(head->next);
    head->next->next = head;  // Link back
    head->next = NULL;        // Break link
    return newHead;
}

// Function to print linked list
void printList(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%d", temp->data);
        if (temp->next != NULL) printf(" -> ");
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    int n, val;
    Node* head = NULL;

    scanf("%d", &n);  // Number of nodes
    for (int i = 0; i < n; i++) {
        scanf("%d", &val);
        insertAtEnd(&head, val);
    }

    head = reverseListRecursive(head);  // Reverse recursively
    printList(head);

    return 0;
}


16. Remove Duplicate Data


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Define Node structure
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Function to create a new node
Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Function to insert at end
void insertAtEnd(Node** head, int value) {
    Node* newNode = createNode(value);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* temp = *head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
}

// Function to remove duplicates
void removeDuplicates(Node* head) {
    if (head == NULL) return;

    bool seen[1001] = {false}; // Constraint: 1 ≤ ai ≤ 1000
    Node* curr = head;
    Node* prev = NULL;

    while (curr != NULL) {
        if (seen[curr->data]) {
            // Duplicate -> remove node
            prev->next = curr->next;
            free(curr);
            curr = prev->next;
        } else {
            seen[curr->data] = true; // Mark value as seen
            prev = curr;
            curr = curr->next;
        }
    }
}

// Function to print list
void printList(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%d", temp->data);
        if (temp->next != NULL) printf(" -> ");
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    int n, val;
    Node* head = NULL;

    scanf("%d", &n); // Number of nodes
    for (int i = 0; i < n; i++) {
        scanf("%d", &val);
        insertAtEnd(&head, val);
    }

    removeDuplicates(head);
    printList(head);

    return 0;
}


17. Delete from front


void deleteNode(struct LinkedList* list, int value) {
    if (list->head == NULL) return;

    if (list->head->value == value) {
        struct Node* targetNode = list->head;
        list->head = targetNode->next;
        free(targetNode);
    }
}



18. Delete from any position


void deleteNode(struct LinkedList* list, int value) {
    if (list->head == NULL) return; // empty list check

    // If the node to delete is at the front
    if (list->head->value == value) {
        struct Node* targetNode = list->head;
        list->head = targetNode->next;  // Move head forward
        free(targetNode);               // Free memory
    } else {
        struct Node* iter = list->head;

        // Traverse the list to find the target node
        while (iter->next != NULL) {
            if (iter->next->value == value) {
                struct Node* targetNode = iter->next;
                iter->next = iter->next->next; // Bypass the target node
                free(targetNode);              // Free memory
                break;                         // Stop after deleting
            }
            iter = iter->next;
        }
    }
}


19. Insertion at end in Circular Linked List


#include <stdio.h>
#include <stdlib.h>

/* Node structure */
struct Node {
    int value;
    struct Node* next;
};

/* Linked List structure */
struct LinkedList {
    struct Node* head;
    struct Node* tail;
};

/* Initialize linked list */
void initList(struct LinkedList* ll) {
    ll->head = NULL;
    ll->tail = NULL;
}

/* Insert at end */
void insertAtEnd(struct LinkedList* ll, int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->value = value;
    newNode->next = NULL;

    if (ll->head == NULL) {
        // First node
        ll->head = newNode;
        ll->tail = newNode;
    } else {
        // Link tail to new node
        ll->tail->next = newNode;
        ll->tail = newNode;
    }

    // Make it circular
    ll->tail->next = ll->head;
}

/* Print values */
void printValues(struct LinkedList* ll) {
    if (ll->head == NULL) {
        return;
    }

    struct Node* current = ll->head;

    do {
        printf("%d ", current->value);
        current = current->next;
    } while (current != ll->head);

    printf("\n");
}

/* Main function */
int main() {
    int n;
    scanf("%d", &n);

    struct LinkedList ll;
    initList(&ll);

    for (int i = 0; i < n; i++) {
        int x;
        scanf("%d", &x);
        insertAtEnd(&ll, x);
    }

    printValues(&ll);

    return 0;
}



20. Deletion in Circular Linked List


void deleteNode(struct LinkedList* ll, int value) {
    // Empty list
    if (ll->head == NULL)
        return;

    // Single node case
    if (ll->head == ll->tail && ll->head->value == value) {
        free(ll->head);
        ll->head = NULL;
        ll->tail = NULL;
        return;
    }

    // If head needs to be deleted
    if (ll->head->value == value) {
        struct Node* temp = ll->head;
        ll->head = ll->head->next;
        ll->tail->next = ll->head;   // maintain circular link
        free(temp);
        return;
    }

    // Otherwise, search for the node
    struct Node* current = ll->head;

    while (current->next != ll->head) {
        if (current->next->value == value) {
            struct Node* targetNode = current->next;
            current->next = targetNode->next;

            // If tail is deleted
            if (targetNode == ll->tail) {
                ll->tail = current;
            }

            free(targetNode);
            return;
        }
        current = current->next;
    }
}



21. Insertion in Doubly Linked List


class LinkedList {
public:
    Node* head;
    Node* tail;

    LinkedList() {
        head = nullptr;
        tail = nullptr;
    }

    void insertAtIndex(int index, int value) {
        Node* newNode = new Node(value);

        if (index == 0) {
            if (head == nullptr) {
                head = tail = newNode;
            } else {
                newNode->next = head;
                head->prev = newNode;
                head = newNode;
            }
            return;
        }

        Node* current = head;
        int currentIndex = 0;
        while (current != nullptr && currentIndex < index - 1) {
            current = current->next;
            currentIndex++;
        }

        if (current == nullptr) {
            delete newNode;
            return;
        }

        if (current == tail) {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
            return;
        }

        newNode->next = current->next;
        newNode->prev = current;
        current->next->prev = newNode;
        current->next = newNode;
    }

    void printValues() {
        if (head == nullptr) {
            return;
        }
        Node* current = head;
        while (current != nullptr) {
            std::cout << current->value << ' ';
            current = current->next;
        }
        std::cout << '\n';
    }
};


22. Deletion - Doubly Linked List


void deleteNode(struct LinkedList* list, int value) {
    struct Node* targetNode = list->head;

    // Find the node with the given value
    while (targetNode && targetNode->value != value) {
        targetNode = targetNode->next;
    }

    if (targetNode == NULL)
        return;

    // Update A and B
    struct Node* A = targetNode->prev;
    struct Node* B = targetNode->next;
    
    // A could be null if target is head
    if (A != NULL) {
        A->next = B;
    }

    // B could be null if target is tail
    if (B != NULL) {
        B->prev = A;
    }

    // If the deleted node was the head, move head to the next node
    if (targetNode == list->head) {
        list->head = B;
    }

    free(targetNode);
}


23. Practice - Josephus Problem


#include <stdio.h>
#include <stdlib.h>

// Node structure
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Function to create a new node
Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Function to solve Josephus problem
int solveJosephus(int n) {
    if (n == 1) return 1;

    // Create circular linked list with 1..n
    Node* head = createNode(1);
    Node* prev = head;
    for (int i = 2; i <= n; i++) {
        Node* newNode = createNode(i);
        prev->next = newNode;
        prev = newNode;
    }
    prev->next = head; // make it circular

    Node* curr = head;
    Node* nextNode;

    // Keep eliminating every second node
    while (curr != curr->next) { // until one node remains
        nextNode = curr->next;       // node to be killed
        curr->next = nextNode->next; // remove nextNode from circle
        free(nextNode);              // free memory
        curr = curr->next;           // move knife to next person
    }

    int winner = curr->data;
    free(curr); // free the last remaining node
    return winner;
}

int main() {
    int T, N;
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &N);
        printf("%d\n", solveJosephus(N));
    }
    return 0;
}



24. Practice - Music Player

#include <stdio.h>
#include <stdlib.h>

// Node structure for doubly linked list
typedef struct Node {
    int songId;
    struct Node* next;
    struct Node* prev;
} Node;

// Playlist structure
typedef struct Playlist {
    Node* head;
    Node* tail;
    Node* curr; // currently playing song
} Playlist;

// Create a new node
Node* createNode(int songId) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->songId = songId;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

// Add song at the end
void addSong(Playlist* list, int songId) {
    Node* newNode = createNode(songId);
    if (list->head == NULL) {
        list->head = list->tail = list->curr = newNode;
    } else {
        list->tail->next = newNode;
        newNode->prev = list->tail;
        list->tail = newNode;
    }
}

// Play next song
void playNext(Playlist* list) {
    if (list->curr && list->curr->next != NULL) {
        list->curr = list->curr->next;
    }
}

// Play previous song
void playPrev(Playlist* list) {
    if (list->curr && list->curr->prev != NULL) {
        list->curr = list->curr->prev;
    }
}

// Switch to a specific songId
void switchSong(Playlist* list, int songId) {
    Node* temp = list->head;
    while (temp != NULL) {
        if (temp->songId == songId) {
            list->curr = temp;
            break;
        }
        temp = temp->next;
    }
}

// Return the current song
int current(Playlist* list) {
    return list->curr->songId;
}

// Example driver (the system will handle input in the actual problem)
int main() {
    int N, type, songId;
    Playlist list = {NULL, NULL, NULL};

    scanf("%d", &N);
    for (int i = 0; i < N; i++) {
        scanf("%d", &type);
        if (type == 1) {
            scanf("%d", &songId);
            addSong(&list, songId);
        } else if (type == 2) {
            playNext(&list);
        } else if (type == 3) {
            playPrev(&list);
        } else if (type == 4) {
            scanf("%d", &songId);
            switchSong(&list, songId);
        } else if (type == 5) {
            printf("%d\n", current(&list));
        }
    }
    return 0;
}


25. Push and Pop


// Remove the __ and complete the code
#define MAX_SIZE 101
int a[MAX_SIZE];
int top = -1;

void push(int ele) {
    if (top < MAX_SIZE - 1) {
        a[++top] = ele;
        printf("Pushed: %d\n", ele);
    } else {
        printf("Stack is full. Cannot push: %d\n", ele);
    }
}

int pop() {
    if (top >= 0) {
        int ele = a[top--];
        printf("Popped: %d\n", ele);
        return ele;
    } else {
        printf("Stack is empty. Cannot pop.\n");
        return -1;
    }
}


26. Peek, isEmpty, isFull


int peek() {
    if (top >= 0) {
        int ele = a[top];
        printf("Peeked: %d\n", ele);
        return ele;
    } else {
        printf("Stack is empty. Cannot peek.\n");
        return -1;
    }
}

int isEmpty() {
    return top == -1;
}

int isFull() {
    if (top >= MAX_SIZE - 1) {
        return 1;
    } else {
        return 0;
    }
}


27. Implement Stack using Arrays


#include <stdio.h>
#include <string.h>

#define STACK_CAPACITY 101
char stackArray[STACK_CAPACITY];
int topIndex = -1;

int isEmpty() {
    return topIndex == -1;
}

int isFull() {
    return topIndex >= STACK_CAPACITY - 1;
}

// Push operation
void push(char character) {
    if (isFull()) {
        printf("Stack is full\n");
        return;
    }
    stackArray[++topIndex] = character;  // Increment topIndex and add element
}

// Pop operation
char pop() {
    if (isEmpty()) {
        printf("Stack is empty\n");
        return '-1';
    }
    return stackArray[topIndex--];  // Return element at top and decrement topIndex
}

int main() {
    char inputString[] = "Hello, World!";
    int inputLength = strlen(inputString);

    // Push each character onto the stack
    for (int i = 0; i < inputLength; i++) {
        push(inputString[i]);
    }

    // Pop the characters from the stack to construct the reversed string
    char reversedString[STACK_CAPACITY];
    int reversedIndex = 0;
    while (!isEmpty()) {
        reversedString[reversedIndex++] = pop();
    }
    reversedString[reversedIndex] = '\0'; // Null terminate the reversed string

    printf("%s\n", reversedString); // Output: !dlroW ,olleH
    return 0;
}


28. Convert Decimal to Binary


#include <stdio.h>
#define MAX 32  // Enough for 32-bit integers

int stack[MAX];
int top = -1;

// Stack functions
void push(int value) {
    if (top >= MAX - 1) return;  // Overflow check
    stack[++top] = value;
}

int pop() {
    if (top == -1) return -1;   // Underflow check
    return stack[top--];
}

int main() {
    int T;
    scanf("%d", &T); // Number of test cases

    while (T--) {
        int n;
        scanf("%d", &n);

        if (n == 0) {
            printf("0\n");
            continue;
        }

        // Push remainders onto the stack
        while (n > 0) {
            push(n % 2);
            n /= 2;
        }

        // Pop stack to print binary representation
        while (top != -1) {
            printf("%d", pop());
        }
        printf("\n");
    }

    return 0;
}


29. Valid Parenthesis

#include <stdio.h>
#include <string.h>

#define MAX 1000

char stack[MAX];
int top = -1;

void push(char ch) {
    if (top < MAX - 1) stack[++top] = ch;
}

char pop() {
    if (top == -1) return '\0';
    return stack[top--];
}

int isValidParenthesis(char* str) {
    top = -1;  // Reset stack for each test case
    int len = strlen(str);

    for (int i = 0; i < len; i++) {
        char ch = str[i];
        if (ch == '(') {
            push(ch);
        } else if (ch == ')') {
            if (top == -1) return 0; // No matching '('
            pop();
        }
    }
    return top == -1;  // Valid if stack is empty
}

int main() {
    int T;
    scanf("%d", &T);
    getchar(); // Consume newline

    while (T--) {
        char str[MAX];
        fgets(str, MAX, stdin);
        str[strcspn(str, "\n")] = '\0'; // Remove newline

        if (isValidParenthesis(str))
            printf("%s : true\n", str);
        else
            printf("%s : false\n", str);
    }

    return 0;
}


30. Evaluate Expression

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100000

struct Stack {
    int top;
    unsigned capacity;
    int* array;
};

struct Stack* createStack(unsigned capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->top = -1;
    stack->capacity = capacity;
    stack->array = (int*)malloc(stack->capacity * sizeof(int));
    return stack;
}

int isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

void push(struct Stack* stack, int item) {
    stack->array[++stack->top] = item;
}

int pop(struct Stack* stack) {
    if (!isEmpty(stack))
        return stack->array[stack->top--];
    return -1;
}

int evaluateSuffixExpression(char* suffix) {
    struct Stack* stack = createStack(strlen(suffix));
    for (int i = 0; suffix[i] != '\0'; i++) {
        char ch = suffix[i];
        if (isdigit(ch)) {
            push(stack, ch - '0');  // Convert char to int
        } else {
            int val2 = pop(stack);
            int val1 = pop(stack);
            int res = 0;
            if (ch == '+')
                res = val1 + val2;
            else if (ch == '-')
                res = val1 - val2;
            else if (ch == '*')
                res = val1 * val2;
            push(stack, res);
        }
    }
    int result = pop(stack);
    free(stack->array);
    free(stack);
    return result;
}

int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        int n;
        scanf("%d", &n);
        char suffix[n + 1];
        scanf("%s", suffix);
        int result = evaluateSuffixExpression(suffix);
        printf("%d\n", result);
    }
    return 0;
}


31. Transform the Expression


#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX 400

// Stack structure for characters (operators and parentheses)
struct Stack {
    char arr[MAX];
    int top;
};

// Initialize stack
void init(struct Stack *s) {
    s->top = -1;
}

// Check if stack is empty
int isEmpty(struct Stack *s) {
    return s->top == -1;
}

// Push element to stack
void push(struct Stack *s, char c) {
    s->arr[++(s->top)] = c;
}

// Pop element from stack
char pop(struct Stack *s) {
    if (isEmpty(s)) return '\0';
    return s->arr[(s->top)--];
}

// Peek top of stack
char peek(struct Stack *s) {
    if (isEmpty(s)) return '\0';
    return s->arr[s->top];
}

// Function to define operator precedence
int precedence(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return 0;
    }
}

// Function to convert infix to postfix (RPN)
void infixToPostfix(char *expr) {
    struct Stack s;
    init(&s);

    for (int i = 0; expr[i] != '\0'; i++) {
        char c = expr[i];

        if (isalpha(c)) {
            // Operand (a-z or A-Z) — output directly
            printf("%c", c);
        } 
        else if (c == '(') {
            push(&s, c);
        } 
        else if (c == ')') {
            // Pop until '('
            while (!isEmpty(&s) && peek(&s) != '(') {
                printf("%c", pop(&s));
            }
            pop(&s); // remove '('
        } 
        else {
            // Operator encountered
            while (!isEmpty(&s) && precedence(peek(&s)) >= precedence(c)) {
                // For right-associative '^', do not pop if equal precedence
                if (c == '^' && precedence(peek(&s)) == precedence(c)) break;
                printf("%c", pop(&s));
            }
            push(&s, c);
        }
    }

    // Pop remaining operators
    while (!isEmpty(&s)) {
        printf("%c", pop(&s));
    }
    printf("\n");
}

// Main function
int main() {
    int t;
    scanf("%d", &t);
    getchar(); // consume newline

    while (t--) {
        char expr[MAX];
        scanf("%s", expr);
        infixToPostfix(expr);
    }

    return 0;
}


32. isEmpty, isFull, functions of Queu

#include <stdio.h>
#include <stdbool.h>

#define maxSize 101
int a[maxSize];
int front = 0; // Index of the front element
int rear = -1;  // Index of the rear element
int currentSize = 0;

int isEmpty() {
    return currentSize == 0;
}


int isFull() {
    return currentSize == maxSize;
}

int size() {
    return currentSize;
}


33. Enqueue and Dequeue Functions


#define MAX 100
int queue[MAX];
int front = 0;
int rear = -1;
int currentSize = 0;
int maxSize = MAX;

// Check if queue is empty
int isEmpty() {
    return currentSize == 0;
}

// Check if queue is full
int isFull() {
    return currentSize == maxSize;
}

// Return current size
int size() {
    return currentSize;
}

// Enqueue function
void enqueue(int item) {
    if (isFull()) {
        printf("Queue Overflow\n");
        return;
    }
    rear = (rear + 1) % maxSize;   // Circularly increment rear
    queue[rear] = item;            // Assign the new item
    currentSize++;                 // Increment current size
}

// Dequeue function
int dequeue() {
    if (isEmpty()) {
        printf("Queue Underflow\n");
        return -1;                 // Sentinel value
    }
    int item = queue[front];        // Get the front item
    front = (front + 1) % maxSize;  // Circularly increment front
    currentSize--;                  // Decrement current size
    return item;                    // Return removed item
}



34. Queue - Print Numbers with a Gi


#include <stdio.h>
#include <stdlib.h>

#define maxSize 101
int a[maxSize];
int front = 0;
int rear = -1;
int currentSize = 0;

int isEmpty() {
    return currentSize == 0;
}

int isFull() {
    return currentSize == maxSize;
}

int size() {
    return currentSize;
}

void enqueue(int item) {
    if (isFull()) return;
    rear = (rear + 1) % maxSize;
    a[rear] = item;
    currentSize++;
}

int dequeue() {
    if (isEmpty()) return -1;
    int removedItem = a[front];
    front = (front + 1) % maxSize;
    currentSize--;
    return removedItem;
}

int main() {
    int n = 10;
    
    for (int i = 1; i <= n; i++) {
        if (i % 2 != 0) {         // Odd numbers → print
            printf("%d ", i);
        } else {                  // Even numbers → enqueue
            enqueue(i);
        }
    }

    while (!isEmpty()) {          // Print remaining enqueued numbers
        printf("%d ", dequeue());
    }

    return 0;
}



35. Queue - To do list


#include <stdio.h>
#include <stdlib.h>

#define maxSize 10
int a[maxSize];
int front = 0; 
int rear = -1;  
int currentSize = 0;

int isEmpty() {
    return currentSize == 0;
}

int isFull() {
    return currentSize == maxSize;
}

int size() {
    return currentSize;
}

void enqueue(int item) {
    if (isFull()) return;
    rear = (rear + 1) % maxSize;
    a[rear] = item;
    currentSize++;
}

int dequeue() {
    if (isEmpty()) return -1;
    int removedItem = a[front];
    front = (front + 1) % maxSize;
    currentSize--;
    return removedItem;
}

int taskList[10];
int taskListsize = 0;

void addTask(int task) {
    // Check if task already exists
    for (int i = 0; i < taskListsize; i++) {
        if (taskList[i] == task)
            return; // Ignore duplicate
    }

    // Add new task
    enqueue(task);
    taskList[taskListsize++] = task;
}

void displayToDoList() {
    for (int i = 0; i < taskListsize; i++) {
        printf("%d ", taskList[i]);
    }
}

int main() {
    int n = 10;
    for (int i = 0; i < n; i++) {
        int task;
        scanf("%d", &task);
        addTask(task);
    }
    displayToDoList();
    return 0;
}


36. Stone Pile


#include <stdio.h>

#define MAXN 200005

long long dq[MAXN];
int front, rear, size;

/* Initialize deque */
void initDeque() {
    front = 0;
    rear = -1;
    size = 0;
}

/* Push at back */
void push_back(long long x) {
    rear = (rear + 1) % MAXN;
    dq[rear] = x;
    size++;
}

/* Pop from front */
long long pop_front() {
    long long val = dq[front];
    front = (front + 1) % MAXN;
    size--;
    return val;
}

/* Get front element */
long long get_front() {
    return dq[front];
}

int main() {
    int T;
    scanf("%d", &T);

    while (T--) {
        int N;
        scanf("%d", &N);

        initDeque();

        for (int i = 0; i < N; i++) {
            long long num;
            scanf("%lld", &num);
            push_back(num);
        }

        int turn = 1;       // Aman = 1, Akshat = 0
        int lastPlayer = -1;

        while (size > 1) {
            if (turn == 1) {
                // Aman: rotate once
                long long top = pop_front();
                push_back(top);

                if (size == 1) {
                    lastPlayer = 1;
                    break;
                }

                pop_front(); // discard
                lastPlayer = 1;
            } else {
                // Akshat: rotate twice
                long long top = pop_front();
                push_back(top);

                if (size == 1) {
                    lastPlayer = 0;
                    break;
                }

                top = pop_front();
                push_back(top);

                if (size == 1) {
                    lastPlayer = 0;
                    break;
                }

                pop_front(); // discard
                lastPlayer = 0;
            }

            turn = 1 - turn; // alternate turns
        }

        printf("%d %lld\n", lastPlayer, get_front());
    }

    return 0;
}


37. Practice problem - Necklace


#include <stdio.h>

int main() {
    int T;
    scanf("%d", &T);

    while (T--) {
        int n, k;
        scanf("%d %d", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf("%d", &arr[i]);
        }

        // Reduce k in case it's greater than n
        k = k % n;

        // Print rotated array directly
        for (int i = 0; i < n; i++) {
            int idx = (i + k) % n; // Compute rotated index
            printf("%d", arr[idx]);
            if (i != n - 1) printf(" ");
        }
        printf("\n");
    }
    return 0;
}


38. Infix to Postfix


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100

struct Stack {
    int top;
    unsigned capacity;
    char* array;
};

struct Stack* createStack(unsigned capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->top = -1;
    stack->capacity = capacity;
    stack->array = (char*)malloc(stack->capacity * sizeof(char));
    return stack;
}

int isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

char peek(struct Stack* stack) {
    return stack->array[stack->top];
}

void push(struct Stack* stack, char item) {
    stack->array[++stack->top] = item;
}

char pop(struct Stack* stack) {
    if (!isEmpty(stack))
        return stack->array[stack->top--];
    return '$';
}

// Function to return precedence of operators
int precedence(char op) {
    switch (op) {
        case '+':
        case '-': return 1;
        case '*':
        case '/': return 2;
        case '^': return 3;
    }
    return 0;
}

// Function to check if character is operator
int isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '^');
}

// Function to convert infix to postfix
void infixToPostfix(char* exp) {
    struct Stack* stack = createStack(strlen(exp));
    int i, k;

    for (i = 0, k = 0; exp[i]; i++) {
        char c = exp[i];

        // If operand, add to output
        if (isalnum(c))
            printf("%c", c);

        // If '(', push to stack
        else if (c == '(')
            push(stack, c);

        // If ')', pop until '('
        else if (c == ')') {
            while (!isEmpty(stack) && peek(stack) != '(')
                printf("%c", pop(stack));
            pop(stack);
        }

        // If operator
        else if (isOperator(c)) {
            while (!isEmpty(stack) && precedence(peek(stack)) >= precedence(c))
                printf("%c", pop(stack));
            push(stack, c);
        }
    }

    // Pop remaining operators
    while (!isEmpty(stack))
        printf("%c", pop(stack));

    printf("\n");
}

int main() {
    int N;
    char exp[MAX_SIZE];

    scanf("%d", &N);
    scanf("%s", exp);

    infixToPostfix(exp);

    return 0;
}


39. String Palindrome using Stack


#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#define MAX 1000

// Function to check if a string is palindrome using stack
bool is_palindrome(char* s) {
    char stack[MAX];
    int top = -1;
    int n = strlen(s);

    // Step 1: Push all characters into stack
    for (int i = 0; i < n; i++) {
        stack[++top] = s[i];
    }

    // Step 2: Compare characters with stack pop
    for (int i = 0; i < n; i++) {
        if (s[i] != stack[top--]) {
            return false;
        }
    }
    return true;
}

int main() {
    char s[1000];
    
    // Input the string to check
    fgets(s, sizeof(s), stdin);
    s[strcspn(s, "\n")] = 0;  // Remove newline character if present
    
    // Check if the string is a palindrome
    if (is_palindrome(s)) {
        printf("Palindrome\n");
    } else {
        printf("Not palindrome\n");
    }

    return 0;
}


40. Check Palindrome using Queue


#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#define MAX 1000

typedef struct {
    char data[MAX];
    int front, rear;
} Queue;

// Initialize the queue
void initQueue(Queue* q) {
    q->front = -1;
    q->rear = -1;
}

// Check if queue is empty
bool isEmpty(Queue* q) {
    return q->front == -1;
}

// Enqueue a character
void enqueue(Queue* q, char c) {
    if (q->rear == MAX - 1) {
        return; // Overflow ignored
    }
    if (isEmpty(q)) {
        q->front = 0;
    }
    q->data[++q->rear] = c;
}

// Dequeue a character
char dequeue(Queue* q) {
    if (isEmpty(q)) {
        return '\0'; // Underflow
    }
    char c = q->data[q->front];
    if (q->front == q->rear) {
        q->front = q->rear = -1; // Reset if last element
    } else {
        q->front++;
    }
    return c;
}

// Function to check palindrome using queue
bool is_palindrome(char* s) {
    int n = strlen(s);
    Queue q;
    initQueue(&q);

    // Step 1: Insert all characters into queue
    for (int i = 0; i < n; i++) {
        enqueue(&q, s[i]);
    }

    // Step 2: Compare with reverse of string
    for (int i = n - 1; i >= 0; i--) {
        if (s[i] != dequeue(&q)) {
            return false;
        }
    }
    return true;
}

int main() {
    char s[1000];

    // Input
    fgets(s, sizeof(s), stdin);
    s[strcspn(s, "\n")] = 0; // Remove newline if present

    // Check palindrome
    if (is_palindrome(s)) {
        printf("Palindrome\n");
    } else {
        printf("Not palindrome\n");
    }

    return 0;
}


41. Implementation - Adjacency Matri


#include <stdio.h>
#include <stdlib.h>

int main(){
   int N;
   scanf("%d", &N);
   
   int arr[10][10] = {0};
   
   for (int i=0; i <= N-1; i++)
    {
        int u,v;
        scanf("%d %d",&u,&v);
        arr[u][v] = 1;
    }
   for ( int i = 0; i<N; i++)
    {
        for ( int j = 0; j< N; j++)
            {
                printf("%d ",arr[i][j]);
            }
        printf("\n");    
    }
    return 0;
}

42. Implementation - Adjacency List

#include <stdio.h>
#include <stdlib.h>


int main() {
    printf("1 2\n");
    printf("3 4\n");
    printf("5");
}


43. Depth First Search

#include <stdio.h>
#include <stdlib.h>

#define MAXX 100005

int visited[MAXX];
int *adj[MAXX];
int size[MAXX];

// Function to add an edge to the adjacency list
void addEdge(int u, int v) {
    adj[u] = realloc(adj[u], (size[u] + 1) * sizeof(int));
    adj[u][size[u]++] = v;

    adj[v] = realloc(adj[v], (size[v] + 1) * sizeof(int));
    adj[v][size[v]++] = u;
}

// DFS function
void dfs(int node) {
    visited[node] = 1;
    printf("%d ", node);
    for (int i = 0; i < size[node]; i++) {
        int child = adj[node][i];
        if (!visited[child]) {
            dfs(child);
        }
    }
}

int main() {
    int n;
    scanf("%d", &n);

    for (int i = 1; i <= n; i++) {
        adj[i] = NULL;
        size[i] = 0;
        visited[i] = 0;
    }

    for (int i = 0; i < n - 1; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        addEdge(u, v);
    }

    dfs(1); // Start DFS from root node 1
    return 0;
}


44.Breadth First Search

#include <stdio.h>
#include <stdlib.h>

#define MAXN 100005

// adjacency list using dynamic memory
int *adj[MAXN];
int adjSize[MAXN];
int visited[MAXN];

// queue for BFS
int queue[MAXN];
int front = 0, rear = 0;

void addEdge(int u, int v) {
    adj[u] = realloc(adj[u], (adjSize[u] + 1) * sizeof(int));
    adj[v] = realloc(adj[v], (adjSize[v] + 1) * sizeof(int));
    adj[u][adjSize[u]++] = v;
    adj[v][adjSize[v]++] = u;
}

void bfs(int start) {
    front = rear = 0;
    queue[rear++] = start;
    visited[start] = 1;

    while (front < rear) {
        int node = queue[front++];
        printf("%d ", node);

        for (int i = 0; i < adjSize[node]; i++) {
            int child = adj[node][i];
            if (!visited[child]) {
                visited[child] = 1;
                queue[rear++] = child;
            }
        }
    }
}

int main() {
    int N;
    scanf("%d", &N);

    for (int i = 0; i < N - 1; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        addEdge(u, v);
    }

    bfs(1);

    // free allocated memory
    for (int i = 1; i <= N; i++) {
        free(adj[i]);
    }

    return 0;
}


45. Count number of leaf nodes


#include <stdio.h>
#include <stdlib.h>

#define MAXN 100005

int *adj[MAXN];
int adjSize[MAXN];
int visited[MAXN];
int leafCount = 0;

void addEdge(int u, int v) {
    adj[u] = realloc(adj[u], (adjSize[u] + 1) * sizeof(int));
    adj[v] = realloc(adj[v], (adjSize[v] + 1) * sizeof(int));
    adj[u][adjSize[u]++] = v;
    adj[v][adjSize[v]++] = u;
}

void dfs(int node, int parent) {
    visited[node] = 1;
    int childCount = 0;

    for (int i = 0; i < adjSize[node]; i++) {
        int child = adj[node][i];
        if (child != parent && !visited[child]) {
            childCount++;
            dfs(child, node);
        }
    }

    // If node has no children => leaf
    if (childCount == 0)
        leafCount++;
}

int main() {
    int N;
    scanf("%d", &N);

    for (int i = 0; i < N - 1; i++) {
        int a, b;
        scanf("%d %d", &a, &b);
        addEdge(a, b);
    }

    dfs(0, -1); // root at node 0

    printf("%d\n", leafCount);

    for (int i = 0; i < N; i++)
        free(adj[i]);

    return 0;
}


46. Height of the tree

#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 100002

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

Node* adj[MAX_NODES];

void add_edge(int u, int v) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = adj[u];
    adj[u] = newNode;
}

void dfs(int node, int parent, int d, int *maxd) {
    if (d > *maxd) {
        *maxd = d;
    }
    Node* current = adj[node];
    while (current != NULL) {
        if (current->vertex != parent) {
            dfs(current->vertex, node, d + 1, maxd);
        }
        current = current->next;
    }
}

int main() {
    int n;
    scanf("%d", &n);

    int depth = 0;

    for (int i = 0; i <= n; i++) {
        adj[i] = NULL;
    }

    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        add_edge(u, v);
        add_edge(v, u);
    }

    dfs(1, -1, 0, &depth);

    printf("%d\n", depth);

    for (int i = 0; i <= n; i++) {
        Node* current = adj[i];
        while (current != NULL) {
            Node* temp = current;
            current = current->next;
            free(temp);
        }
    }

    return 0;
}


47.  Nodes at Kth Level

#include <stdio.h>
#include <stdlib.h>

#define MAXN 100005

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

Node* adj[MAXN];
int visited[MAXN];
int level[MAXN];

// Function to add edges to adjacency list
void addEdge(int u, int v) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = adj[u];
    adj[u] = newNode;
}

// BFS to calculate levels of each node
void bfs(int root, int n) {
    int queue[MAXN], front = 0, rear = 0;

    visited[root] = 1;
    level[root] = 0;
    queue[rear++] = root;

    while (front < rear) {
        int node = queue[front++];
        Node* temp = adj[node];

        while (temp != NULL) {
            int v = temp->vertex;
            if (!visited[v]) {
                visited[v] = 1;
                level[v] = level[node] + 1;
                queue[rear++] = v;
            }
            temp = temp->next;
        }
    }
}

int cmp(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int n, k;
    scanf("%d %d", &n, &k);

    for (int i = 0; i <= n; i++) {
        adj[i] = NULL;
        visited[i] = 0;
        level[i] = -1;
    }

    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        addEdge(u, v);
        addEdge(v, u);
    }

    bfs(1, n);

    int nodesAtK[MAXN];
    int count = 0;

    for (int i = 1; i <= n; i++) {
        if (level[i] == k) {
            nodesAtK[count++] = i;
        }
    }

    qsort(nodesAtK, count, sizeof(int), cmp);

    for (int i = 0; i < count; i++) {
        printf("%d ", nodesAtK[i]);
    }

    return 0;
}


48. Tree Path Sum

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_NODES 100002

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

Node* adj[MAX_NODES];
bool check;
int degree[MAX_NODES];

void add_edge(int u, int v) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = adj[u];
    adj[u] = newNode;
}

// DFS to find root-to-leaf path with given sum
void dfs(int node, int par, int s, int target_sum) {
    s += node;  // Add current node value to path sum

    bool isLeaf = true;
    for (Node* cur = adj[node]; cur != NULL; cur = cur->next) {
        if (cur->vertex != par) {
            isLeaf = false;
            dfs(cur->vertex, node, s, target_sum);
        }
    }

    // If it's a leaf node and path sum == target_sum
    if (isLeaf && s == target_sum) {
        check = true;
    }
}

int main() {
    int n, target_sum;
    scanf("%d %d", &n, &target_sum);

    check = false;
    memset(degree, 0, sizeof(degree));

    for (int i = 0; i <= n; i++) adj[i] = NULL;

    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        degree[u]++;
        degree[v]++;
        add_edge(u, v);
        add_edge(v, u);
    }

    dfs(1, -1, 0, target_sum);

    printf("%s\n", check ? "YES" : "NO");

    // Free memory
    for (int i = 0; i <= n; i++) {
        Node* current = adj[i];
        while (current != NULL) {
            Node* temp = current;
            current = current->next;
            free(temp);
        }
    }

    return 0;
}


49. Neighbours of node


#include <stdio.h>

int main(void) {
    int n, v;
    scanf("%d %d", &n, &v);

    int u1, u2;
    int count = 0;

    for (int i = 0; i < n - 1; i++) {
        scanf("%d %d", &u1, &u2);
        if (u1 == v || u2 == v) {
            count++;  // Count edges connected to node v
        }
    }

    printf("%d\n", count);
    return 0;
}

50. Subtree Sum


#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 100002

// Global arrays for adjacency list and subtree sum
int *adj[MAX_NODES];
int adjSize[MAX_NODES];
int adjCap[MAX_NODES];
long long subtsum[MAX_NODES];

// Function to add an edge to the adjacency list for node u
void addEdge(int u, int v) {
    if (adjSize[u] == adjCap[u]) {
        // Increase capacity: start with 2 or double the capacity
        if (adjCap[u] == 0)
            adjCap[u] = 2;
        else
            adjCap[u] *= 2;
        int *temp = realloc(adj[u], adjCap[u] * sizeof(int));
        if (temp == NULL) {
            exit(1);
        }
        adj[u] = temp;
    }
    adj[u][adjSize[u]++] = v;
}

// DFS function to compute subtree sum
void dfs(int node, int par) {
    subtsum[node] += node;  // add current node's value
    for (int i = 0; i < adjSize[node]; i++) {
        int v = adj[node][i];
        if (v != par) {
            dfs(v, node);
            subtsum[node] += subtsum[v];
        }
    }
}

int main() {
    int n;
    if (scanf("%d", &n) != 1) return 1;
    
    // Initialize the arrays for nodes 1 through n.
    for (int i = 1; i <= n; i++) {
        adj[i] = NULL;
        adjSize[i] = 0;
        adjCap[i] = 0;
        subtsum[i] = 0;
    }
    
    // Read the tree edges and build the undirected graph
    for (int i = 1; i < n; i++) {
        int u, v;
        if (scanf("%d %d", &u, &v) != 2) break;
        addEdge(u, v);
        addEdge(v, u);
    }
    
    // Run DFS from node 1, with parent -1 (indicating no parent)
    dfs(1, -1);
    
    // Print the subtree sums for each node (from 1 to n)
    for (int i = 1; i <= n; i++) {
        printf("%lld ", subtsum[i]);
    }
    printf("\n");
    
    // Free the allocated memory for each node's adjacency list
    for (int i = 1; i <= n; i++) {
        free(adj[i]);
    }
    
    return 0;
}


51. Diameter of the tree


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 100005

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

Node* adj[MAX];
int visited[MAX];
int farthest_node;
int max_dist;

// Add edge in adjacency list
void add_edge(int u, int v) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = adj[u];
    adj[u] = newNode;
}

// DFS to find farthest node and distance
void dfs(int node, int dist) {
    visited[node] = 1;
    if (dist > max_dist) {
        max_dist = dist;
        farthest_node = node;
    }

    Node* temp = adj[node];
    while (temp != NULL) {
        int v = temp->vertex;
        if (!visited[v]) dfs(v, dist + 1);
        temp = temp->next;
    }
}

int main(void) {
    int n;
    scanf("%d", &n);

    for (int i = 1; i <= n; i++) adj[i] = NULL;

    for (int i = 0; i < n - 1; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        add_edge(u, v);
        add_edge(v, u);
    }

    // Step 1: Run DFS from any node (1) to find farthest node
    memset(visited, 0, sizeof(visited));
    max_dist = -1;
    dfs(1, 0);

    // Step 2: Run DFS from that farthest node to find max distance (diameter)
    memset(visited, 0, sizeof(visited));
    max_dist = -1;
    dfs(farthest_node, 0);

    printf("%d\n", max_dist);
    return 0;
}


52. LCA of two nodes


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 100005

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

Node* adj[MAX];
int parent[MAX];
int depth[MAX];
int visited[MAX];

// Add edge to adjacency list
void add_edge(int u, int v) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = adj[u];
    adj[u] = newNode;
}

// DFS to compute parent and depth of each node
void dfs(int node, int par, int d) {
    visited[node] = 1;
    parent[node] = par;
    depth[node] = d;

    Node* temp = adj[node];
    while (temp != NULL) {
        int v = temp->vertex;
        if (!visited[v]) {
            dfs(v, node, d + 1);
        }
        temp = temp->next;
    }
}

// Function to find LCA of u and v
int findLCA(int u, int v) {
    // Bring both nodes to the same depth
    while (depth[u] > depth[v]) u = parent[u];
    while (depth[v] > depth[u]) v = parent[v];

    // Move up together until they meet
    while (u != v) {
        u = parent[u];
        v = parent[v];
    }
    return u;
}

int main(void) {
    int n, u, v;
    scanf("%d %d %d", &n, &u, &v);

    // Initialize adjacency list
    for (int i = 1; i <= n; i++) {
        adj[i] = NULL;
        visited[i] = 0;
    }

    // Read edges
    for (int i = 0; i < n - 1; i++) {
        int a, b;
        scanf("%d %d", &a, &b);
        add_edge(a, b);
        add_edge(b, a);
    }

    // Run DFS from root node (1)
    dfs(1, -1, 0);

    // Find and print LCA
    printf("%d\n", findLCA(u, v));

    return 0;
}



53. Distance between two nodes

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 100005

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

Node* adj[MAX];
int parent[MAX];
int depth[MAX];
int visited[MAX];

// Add edge to adjacency list
void add_edge(int u, int v) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = adj[u];
    adj[u] = newNode;
}

// DFS to compute parent and depth of each node
void dfs(int node, int par, int d) {
    visited[node] = 1;
    parent[node] = par;
    depth[node] = d;

    Node* temp = adj[node];
    while (temp != NULL) {
        int v = temp->vertex;
        if (!visited[v]) {
            dfs(v, node, d + 1);
        }
        temp = temp->next;
    }
}

// Function to find LCA of u and v
int findLCA(int u, int v) {
    // Bring both nodes to the same depth
    while (depth[u] > depth[v]) u = parent[u];
    while (depth[v] > depth[u]) v = parent[v];

    // Move up together until they meet
    while (u != v) {
        u = parent[u];
        v = parent[v];
    }
    return u;
}

int main(void) {
    int n, u, v;
    scanf("%d %d %d", &n, &u, &v);

    // Initialize adjacency list
    for (int i = 1; i <= n; i++) {
        adj[i] = NULL;
        visited[i] = 0;
    }

    // Read edges
    for (int i = 0; i < n - 1; i++) {
        int a, b;
        scanf("%d %d", &a, &b);
        add_edge(a, b);
        add_edge(b, a);
    }

    // Run DFS from root node (1)
    dfs(1, -1, 0);

    // Compute distance using depths and LCA
    int lca = findLCA(u, v);
    int distance = depth[u] + depth[v] - 2 * depth[lca];

    printf("%d\n", distance);

    return 0;
}


54. Kth ancestor of the node

#include <stdio.h>
#include <stdlib.h>

#define MAX 100005

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

Node* adj[MAX];
int parent[MAX];
int visited[MAX];

// Add edge to adjacency list
void add_edge(int u, int v) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = adj[u];
    adj[u] = newNode;
}

// DFS to compute parent of each node
void dfs(int node, int par) {
    visited[node] = 1;
    parent[node] = par;

    Node* temp = adj[node];
    while (temp != NULL) {
        int v = temp->vertex;
        if (!visited[v]) {
            dfs(v, node);
        }
        temp = temp->next;
    }
}

int main(void) {
    int n, K, v;
    scanf("%d %d %d", &n, &K, &v);

    // Initialize adjacency list
    for (int i = 1; i <= n; i++) {
        adj[i] = NULL;
        visited[i] = 0;
    }

    // Read edges
    for (int i = 0; i < n - 1; i++) {
        int a, b;
        scanf("%d %d", &a, &b);
        add_edge(a, b);
        add_edge(b, a);
    }

    // Compute parents using DFS starting from root 1
    dfs(1, -1);

    // Move up K times from node v
    int current = v;
    for (int i = 0; i < K; i++) {
        current = parent[current];
    }

    printf("%d\n", current);

    return 0;
}


55. Largest value at each level


#include <stdio.h>
#include <stdlib.h>

#define MAX 100005
#define MAX_QUEUE 100005

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

Node* adj[MAX];

// Queue for BFS
int queue[MAX_QUEUE];
int front = 0, rear = 0;

// Enqueue
void enqueue(int x) {
    queue[rear++] = x;
}

// Dequeue
int dequeue() {
    return queue[front++];
}

// Check if queue is empty
int isEmpty() {
    return front == rear;
}

// Add edge to adjacency list
void add_edge(int u, int v) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = adj[u];
    adj[u] = newNode;
}

int main() {
    int n;
    scanf("%d", &n);

    for(int i = 1; i <= n; i++)
        adj[i] = NULL;

    // Read edges
    for(int i = 0; i < n - 1; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        add_edge(u, v);
        add_edge(v, u);
    }

    int visited[MAX] = {0};
    int levels[MAX] = {0}; // store max value at each level
    int maxLevel = 0;

    enqueue(1);
    visited[1] = 1;
    levels[0] = 1; // root node at level 0

    int level = 0;

    while(!isEmpty()) {
        int size = rear - front;
        int maxVal = 0;

        for(int i = 0; i < size; i++) {
            int node = dequeue();
            if(node > maxVal) maxVal = node;

            Node* temp = adj[node];
            while(temp != NULL) {
                if(!visited[temp->vertex]) {
                    enqueue(temp->vertex);
                    visited[temp->vertex] = 1;
                }
                temp = temp->next;
            }
        }

        levels[level++] = maxVal;
    }

    printf("%d\n", level);
    for(int i = 0; i < level; i++) {
        printf("%d ", levels[i]);
    }
    printf("\n");

    return 0;
}


56. Distinct colors in subtrees


#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 100001

int n, col[MAX_NODES], distinct[MAX_NODES];
int *adj[MAX_NODES];
int adj_size[MAX_NODES];

// Dynamic array to hold colors
typedef struct {
    int *data;
    int size;
    int capacity;
} DynamicArray;

void init_array(DynamicArray *arr) {
    arr->size = 0;
    arr->capacity = 2;
    arr->data = (int *)malloc(arr->capacity * sizeof(int));
}

void append(DynamicArray *arr, int value) {
    if (arr->size == arr->capacity) {
        arr->capacity *= 2;
        arr->data = (int *)realloc(arr->data, arr->capacity * sizeof(int));
    }
    arr->data[arr->size++] = value;
}

void merge_arrays(DynamicArray *dest, DynamicArray *src) {
    for (int i = 0; i < src->size; i++) {
        append(dest, src->data[i]);
    }
}

int compare(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}

void deduplicate(DynamicArray *arr) {
    if (arr->size == 0) return;
    qsort(arr->data, arr->size, sizeof(int), compare);
    int j = 0;
    for (int i = 1; i < arr->size; i++) {
        if (arr->data[i] != arr->data[j]) {
            arr->data[++j] = arr->data[i];
        }
    }
    arr->size = j + 1;
}

void dfs(int node, int par, DynamicArray *colors[]) {
    append(colors[node], col[node]);

    for (int i = 0; i < adj_size[node]; i++) {
        int child = adj[node][i];
        if (child != par) {
            dfs(child, node, colors);
            if (colors[child]->size > colors[node]->size) {
                DynamicArray *temp = colors[child];
                colors[child] = colors[node];
                colors[node] = temp;
            }
            merge_arrays(colors[node], colors[child]);
        }
    }

    deduplicate(colors[node]);
    distinct[node] = colors[node]->size;
}

int main() {
    int x, y;
    scanf("%d", &n);

    for (int i = 1; i <= n; i++) {
        scanf("%d", &col[i]);
        adj[i] = (int *)malloc(MAX_NODES * sizeof(int));
        adj_size[i] = 0;
    }

    for (int i = 1; i < n; i++) {
        scanf("%d %d", &x, &y);
        adj[x][adj_size[x]++] = y;
        adj[y][adj_size[y]++] = x;
    }

    DynamicArray *colors[MAX_NODES];
    for (int i = 1; i <= n; i++) {
        colors[i] = (DynamicArray *)malloc(sizeof(DynamicArray));
        init_array(colors[i]);
    }

    dfs(1, 0, colors);

    for (int i = 1; i <= n; i++) {
        printf("%d ", distinct[i]);
    }
    printf("\n");

    // Free allocated memory
    for (int i = 1; i <= n; i++) {
        free(colors[i]->data);
        free(colors[i]);
        free(adj[i]);
    }

    return 0;
}


57. Minimum time to collect all coins

#include <stdio.h>
#include <stdlib.h>

#define MAXN 100005

int N;
int hasCoin[MAXN];
int adj[MAXN][10]; // adjacency list, adjust if node degree > 10
int deg[MAXN];
int visited[MAXN];

// DFS returns whether the subtree rooted at u has any coin
int dfs(int u) {
    visited[u] = 1;
    int total = 0;
    for (int i = 0; i < deg[u]; i++) {
        int v = adj[u][i];
        if (!visited[v]) {
            int sub = dfs(v);
            if (sub > 0 || hasCoin[v]) {
                total += sub + 2; // 2 for edge u-v
            }
        }
    }
    return total;
}

int main() {
    scanf("%d", &N);
    for (int i = 1; i <= N; i++)
        scanf("%d", &hasCoin[i]);

    for (int i = 0; i < N-1; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        adj[u][deg[u]++] = v;
        adj[v][deg[v]++] = u;
    }

    for (int i = 1; i <= N; i++) visited[i] = 0;
    int result = dfs(1);
    printf("%d\n", result);
    return 0;
}



58. Implementation - Binary Tree

#include <stdio.h>
#include <stdlib.h>

struct node{
    int val;
    struct node* left;
    struct node* right;
};

struct node* node_new(int val){
    struct node* temp = (struct node*)malloc(sizeof(struct node));
    temp->val = val;
    temp->left = NULL;
    temp->right = NULL;
    return temp;
}

int main() {
    // Creating our root node
    struct node* root = node_new(0);
    // Assigning node '1' to the left of '0'
    root->left = node_new(1);
    // Assigning node '2' to the right of '0'
    root->right = node_new(2);
    // Similarly for the child nodes of the left(1)
    root->left->left = node_new(3);
    root->left->right = node_new(4);
    printf("The tree is created!\n");
    return 0;
}


59. PreOrder Traversal

typedef struct Solution {
    void (*preOrderTraversal)(Node* root);
} Solution;

void preOrderTraversal(Node* root) {
    if (root == NULL)
        return;
    printf("%d ", root->val);
    preOrderTraversal(root->left);
    preOrderTraversal(root->right);
}

Solution* createSolution() {
    Solution* sol = (Solution*)malloc(sizeof(Solution));
    sol->preOrderTraversal = preOrderTraversal;
    return sol;
}


60. PostOrder Traversal


// Function to perform post-order traversal
void postOrderTraversal(Node* root) {
    if (root == NULL) {
        return;
    }
    postOrderTraversal(root->left);    // Traverse the left subtree
    postOrderTraversal(root->right);   // Traverse the right subtree
    printf("%d ", root->val);          // Visit the root
}


61.InOrder Traversal

// Function to perform in-order traversal
void inOrderTraversal(Node* root) {
    if (!root) return;      // base case: empty node
    inOrderTraversal(root->left);  // traverse left subtree
    printf("%d ", root->val);      // visit root
    inOrderTraversal(root->right); // traverse right subtree
}


62. Height of Binary Tree


int heightOfBinaryTree(Node* root) {
    if (!root) return -1;  // height of empty tree is -1 (number of edges)
    
    int leftHeight = heightOfBinaryTree(root->left);
    int rightHeight = heightOfBinaryTree(root->right);
    
    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
}


63. Height Balanced Binary Tree

int checkHeight(struct Node* root) {
    if (!root) return 0;  // height of empty subtree is 0

    int leftHeight = checkHeight(root->left);
    if (leftHeight == -1) return -1;  // left subtree unbalanced

    int rightHeight = checkHeight(root->right);
    if (rightHeight == -1) return -1;  // right subtree unbalanced

    if (abs(leftHeight - rightHeight) > 1) return -1;  // current node unbalanced

    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
}

void isHeightBalanced(struct Node* root) {
    if (checkHeight(root) == -1)
        printf("NO\n");
    else
        printf("YES\n");
}


64.Identical Binary Trees


int areIdenticalTrees(Node* root1, Node* root2) {
    if (root1 == NULL && root2 == NULL) 
        return 1;  // both empty, identical

    if (root1 == NULL || root2 == NULL) 
        return 0;  // one is empty, not identical

    if (root1->val != root2->val) 
        return 0;  // values differ

    // recursively check left and right subtrees
    return areIdenticalTrees(root1->left, root2->left) &&
           areIdenticalTrees(root1->right, root2->right);
}


65. Mirror Tree


int isMirror(struct Node* t1, struct Node* t2) {
    if (t1 == NULL && t2 == NULL)
        return 1;
    if (t1 == NULL || t2 == NULL)
        return 0;
    return isMirror(t1->left, t2->right) && isMirror(t1->right, t2->left);
}

void isMirrorTree(struct Node* root) {
    if (isMirror(root, root))
        printf("YES\n");
    else
        printf("NO\n");
}


66. Level Order Traversal


// struct Node {
//     int val;
//     struct Node* left;
//     struct Node* right;

//     struct Node(int val) {
//         this->val = val;
//         left = right = NULL;
//     }
// };

#define MAX_NODES 100001

void levelOrderTraversal(struct Node* root) {
    if (root == NULL) {
        return;
    }

    struct Node* queue[MAX_NODES];
    int front = 0, rear = 0;
    queue[rear++] = root;

    while (front < rear) {
        int levelSize = rear - front;
        int levelValues[MAX_NODES];
        int levelIndex = 0;

        for (int i = 0; i < levelSize; i++) {
            struct Node* node = queue[front++];

            if (node->left != NULL) {
                queue[rear++] = node->left;
            }
            if (node->right != NULL) {
                queue[rear++] = node->right;
            }

            levelValues[levelIndex++] = node->val;
        }

        for (int i = 0; i < levelIndex; i++) {
            printf("%d ", levelValues[i]);
        }
        printf("\n");
    }
}



67. ZigZag Traversal


void zigzagTraversal(struct Node* root) {
    if (!root) return;

    struct Node* queue[10000];
    int front = 0, rear = 0;
    queue[rear++] = root;

    int leftToRight = 1;

    while (front < rear) {
        int levelSize = rear - front;
        int levelNodes[levelSize];

        for (int i = 0; i < levelSize; i++) {
            struct Node* curr = queue[front++];
            if (leftToRight)
                levelNodes[i] = curr->val;
            else
                levelNodes[levelSize - i - 1] = curr->val;

            if (curr->left) queue[rear++] = curr->left;
            if (curr->right) queue[rear++] = curr->right;
        }

        for (int i = 0; i < levelSize; i++) {
            printf("%d", levelNodes[i]);
            if (i != levelSize - 1) printf(" ");
        }
        printf("\n");
        leftToRight = !leftToRight;
    }
}


68. Boundary of the Binary Tree

#include <stdio.h>

void printLeaves(struct Node* root) {
    if (!root) return;
    printLeaves(root->left);
    if (!root->left && !root->right)
        printf("%d ", root->val);
    printLeaves(root->right);
}

void printLeftBoundary(struct Node* root) {
    if (!root) return;
    if (root->left) {
        printf("%d ", root->val);
        printLeftBoundary(root->left);
    } else if (root->right) {
        printf("%d ", root->val);
        printLeftBoundary(root->right);
    }
    // Do nothing if leaf node
}

void printRightBoundary(struct Node* root) {
    if (!root) return;
    if (root->right) {
        printRightBoundary(root->right);
        printf("%d ", root->val);
    } else if (root->left) {
        printRightBoundary(root->left);
        printf("%d ", root->val);
    }
    // Do nothing if leaf node
}

void printBoundary(struct Node* root) {
    if (!root) return;
    printf("%d ", root->val);          // Root node
    printLeftBoundary(root->left);     // Left boundary excluding leaves
    printLeaves(root->left);           // All leaves from left subtree
    printLeaves(root->right);          // All leaves from right subtree
    printRightBoundary(root->right);   // Right boundary excluding leaves
}


69. Top view of the Binary Tree


#include <stdio.h>
#include <stdlib.h>

typedef struct QueueNode {
    struct Node* treeNode;
    int hd; // horizontal distance
    struct QueueNode* next;
} QueueNode;

typedef struct Queue {
    QueueNode* front;
    QueueNode* rear;
} Queue;

Queue* createQueue() {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    q->front = q->rear = NULL;
    return q;
}

void enqueue(Queue* q, struct Node* node, int hd) {
    QueueNode* temp = (QueueNode*)malloc(sizeof(QueueNode));
    temp->treeNode = node;
    temp->hd = hd;
    temp->next = NULL;
    if (!q->rear) {
        q->front = q->rear = temp;
        return;
    }
    q->rear->next = temp;
    q->rear = temp;
}

QueueNode* dequeue(Queue* q) {
    if (!q->front) return NULL;
    QueueNode* temp = q->front;
    q->front = q->front->next;
    if (!q->front) q->rear = NULL;
    return temp;
}

int isEmpty(Queue* q) {
    return q->front == NULL;
}

void topView(Node* root) {
    if (!root) return;

    // Track min and max horizontal distance
    int hdMin = 0, hdMax = 0;

    // Store top view nodes: 20001 for offsets to handle negative hd
    int top[20001] = {0}; // 0 means no node assigned yet

    Queue* q = createQueue();
    enqueue(q, root, 0);

    while (!isEmpty(q)) {
        QueueNode* qn = dequeue(q);
        Node* node = qn->treeNode;
        int hd = qn->hd;
        free(qn);

        if (top[hd + 10000] == 0) {
            top[hd + 10000] = node->val;
            if (hd < hdMin) hdMin = hd;
            if (hd > hdMax) hdMax = hd;
        }

        if (node->left) enqueue(q, node->left, hd - 1);
        if (node->right) enqueue(q, node->right, hd + 1);
    }

    for (int i = hdMin; i <= hdMax; i++) {
        printf("%d ", top[i + 10000]);
    }
}



70. Minimum Depth of Binary Tree


#include <stdio.h>
#include <stdlib.h>

int minimumDepth(struct Node* root) {
    if (root == NULL) return 0;

    // If left child is NULL, recurse only on right
    if (root->left == NULL) return 1 + minimumDepth(root->right);

    // If right child is NULL, recurse only on left
    if (root->right == NULL) return 1 + minimumDepth(root->left);

    // If both children exist, take the minimum of both
    int leftDepth = minimumDepth(root->left);
    int rightDepth = minimumDepth(root->right);

    return 1 + (leftDepth < rightDepth ? leftDepth : rightDepth);
}


71. Construct Binary Tree


Node* newNode(int val) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->val = val;
    node->left = node->right = NULL;
    return node;
}

Node* build(int* preorder, int* inorder, int* rootIdx, int left, int right, int n) {
    if (left > right) return NULL;
    int pivot = left;
    while (pivot <= right && inorder[pivot] != preorder[*rootIdx]) {
        pivot++;
    }

    if (pivot > right) {
        // Invalid tree configuration
        exit(1);
    }

    int rootVal = inorder[pivot];
    (*rootIdx)++;
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->val = rootVal;
    newNode->left = build(preorder, inorder, rootIdx, left, pivot - 1, n);
    newNode->right = build(preorder, inorder, rootIdx, pivot + 1, right, n);
    return newNode;
}


72. Sum of deepest leaves


void deepLSum(Node* root, int* maxLevel, int curLevel, int* ans) {
    if (root == NULL) return;
    if (curLevel > *maxLevel) {
        *ans = root->val;
    } else if (curLevel == *maxLevel) {
        *ans += root->val;
    }
    *maxLevel = (*maxLevel > curLevel) ? *maxLevel : curLevel;
    deepLSum(root->left, maxLevel, curLevel + 1, ans);
    deepLSum(root->right, maxLevel, curLevel + 1, ans);
}

int deepestLeavesSum(Node* root) {
    int mxL = 0, ans = 0;
    deepLSum(root, &mxL, 0, &ans);
    return ans;
}


73. Find the Subtree

bool check(Node* n1, Node* n2) {
    if (n1 == NULL && n2 == NULL) return true;
    if (n1 == NULL || n2 == NULL || n1->val != n2->val) return false;
    return check(n1->left, n2->left) && check(n1->right, n2->right);
}

bool findSubtree(Node* root1, Node* root2){
    if (root1 == NULL && root2 == NULL) return true;
    if (root1 == NULL) return false;
    return check(root1, root2) || findSubtree(root1->left, root2) || findSubtree(root1->right, root2);
}


74. Reconstruct the Tree

// Function to reconstruct the binary tree from traversal list
Node* reconstruct(int* traversal, int size) {
    if (size == 0) {
        return NULL;
    }
    
    Node* root = createNode(traversal[0]);
    Node* queue[10000];  // Assumes maximum tree size <= 10000
    int front = 0, rear = 0;
    
    queue[rear++] = root;
    
    int i = 1;
    while (front < rear && i < size) {
        Node* current = queue[front++];
        
        int leftValue = traversal[i++];
        if (leftValue != -1) {
            current->left = createNode(leftValue);
            queue[rear++] = current->left;
        }
        
        if (i < size) {
            int rightValue = traversal[i++];
            if (rightValue != -1) {
                current->right = createNode(rightValue);
                queue[rear++] = current->right;
            }
        }
    }
    return root;
}



75. Triplet LCA


#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 100001

int edges[MAX_NODES][2];  // Fixed size for simplicity
int edge_count[MAX_NODES]; // To track the number of edges for each node
int _ans;

struct Node {
    int data;
    struct Node *left, *right;
};

// Function to create a new node with given data
struct Node* createNode(int x) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode->data = x;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to create a tree from edges
struct Node* makeTree(int node) {
    struct Node* curNode = createNode(node);

    if (edge_count[node] >= 1) {
        curNode->left = makeTree(edges[node][0]);
    }
    if (edge_count[node] == 2) {
        curNode->right = makeTree(edges[node][1]);
    }

    return curNode;
}

// Check if a node's data is present in the array
int contains(int* nodes, int size, int data) {
    for (int i = 0; i < size; i++) {
        if (nodes[i] == data) {
            return 1;
        }
    }
    return 0;
}

// Find the LCA of nodes present in the array
struct Node* findLCA(struct Node* root, int* nodes, int size) {
    if (root == NULL) {
        return NULL;
    }
    if (contains(nodes, size, root->data)) {
        return root;
    }

    struct Node* leftLCA = findLCA(root->left, nodes, size);
    struct Node* rightLCA = findLCA(root->right, nodes, size);

    if (leftLCA && rightLCA) {
        return root;
    }
    return leftLCA != NULL ? leftLCA : rightLCA;
}

// Function to find LCA of three nodes
int tripletLCA(struct Node* root, int a, int b, int c) {
    int nodes[3] = {a, b, c}; // Store the three nodes
    struct Node* lca = findLCA(root, nodes, 3);
    return lca != NULL ? lca->data : -1;
}

int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        int n;
        scanf("%d", &n);

        // Initialize edge counts to 0
        for (int i = 0; i <= n; i++) {
            edge_count[i] = 0;
        }

        // Input the edges
        for (int i = 0; i < n; i++) {
            int x, y;
            scanf("%d %d", &x, &y);
            if (x != -1) {
                edges[x][edge_count[x]++] = y;
            }
        }

        int a[3];
        scanf("%d %d %d", &a[0], &a[1], &a[2]);

        // Create the binary tree from the edge list
        struct Node* root = makeTree(1);

        // Find the LCA of the triplet
        _ans = tripletLCA(root, a[0], a[1], a[2]);

        // Output the answer
        printf("%d\n", _ans);
    }
    return 0;
}



76.  Trees - Branch Sum


#include <stdio.h>

struct node {
    int vertex;
    struct node* next;
};

struct Graph {
    int numVertices;
    struct node** adjLists;
};

// Create a node
struct node* createNode(int v) {
    struct node* newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

// Create a graph
struct Graph* createAGraph(int vertices) {
    struct Graph* graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->adjLists = malloc(vertices * sizeof(struct node*));

    // Initializing the linked list of all vertices as NULL
    for (int i=0 ; i<vertices ; i++){
        graph->adjLists[i] = NULL;
    }
    return graph;
}

// Add edge
void addEdge(struct Graph* graph, int s, int d) {
  // Add edge from s to d
  struct node* newNode = createNode(d);
  // Inserting d in the beginning of list of s
  newNode->next = graph->adjLists[s];
  // Setting d as the new head
  graph->adjLists[s] = newNode;

  // Add edge from d to s
  newNode = createNode(s);
  newNode->next = graph->adjLists[d];
  graph->adjLists[d] = newNode;
}

int sum;
int mod = 1e9+7;

void dfs(int vertex,long long cur_val,int vis[],int val[],struct Graph* graph){
    vis[vertex]=1;
    int leaf = 1;
    long long new_val = (cur_val*10+val[vertex])%mod;
    struct node* temp = graph->adjLists[vertex];
    while(temp!=NULL){
        int child = temp->vertex;
        if(!vis[child]){
            dfs(child,new_val,vis,val,graph);
            leaf=0;
        }
        temp = temp->next;
    }
    if(leaf){
        sum=(sum+new_val)%mod;
    }
}

int main(void) {
    int tc;
    scanf("%d",&tc);
    while(tc--){
        int n;
        scanf("%d",&n);
        int val[n+1];
	    for(int i=1 ; i<=n ; i++){
	        scanf("%d",&val[i]);
	    }
        // Creating adjacency List
        struct Graph* graph = createAGraph(n+1);
        // Taking edges input
        for(int i=0 ; i<n-1 ; i++){
            int a,b;
            scanf("%d",&a);
            scanf("%d",&b);
            addEdge(graph,a,b);
        }
        int vis[n+1];
        memset(vis,0,sizeof(vis));
        sum=0;
	    dfs(1,0,vis,val,graph);
	    printf("%d\n",sum);
    }
	return 0;
}


77. Paths with given sum


void traverse(Node* root, int paths[][1000], int* path, int* pathLength, int* numPaths, int target, int currentSum) {
    if (root == NULL) return;

    path[(*pathLength)++] = root->val;
    currentSum += root->val;

    if (root->left == NULL && root->right == NULL) {
        if (currentSum == target) {
            for (int i = 0; i < *pathLength; i++) {
                paths[*numPaths][i] = path[i]; // Store the path
            }
            (*numPaths)++;
        }
    } else {
        traverse(root->left, paths, path, pathLength, numPaths, target, currentSum);
        traverse(root->right, paths, path, pathLength, numPaths, target, currentSum);
    }

    (*pathLength)--;
}

void targetSumPaths(Node* root, int target) {
    int path[1000]; // Assuming max path length is 1000
    int paths[100000][1000]; // Assuming max number of paths is 100000
    int pathLength = 0;
    int numPaths = 0;

    traverse(root, paths, path, &pathLength, &numPaths, target, 0);

    for (int i = 0; i < numPaths; i++) {
        for (int j = 0; j < 1000 && paths[i][j] != 0; j++) {
            printf("%d ", paths[i][j]);
        }
        printf("\n");
    }
}


78. Implementation - Create BST

#include <stdio.h>
#include <stdlib.h>

struct node{
    int val;
    struct node* left;
    struct node* right;
};

struct node* node_new(int val){
    struct node* temp = (struct node*)malloc(sizeof(struct node));
    temp->val = val;
    temp->left = NULL;
    temp->right = NULL;
    return temp;
}

struct node* root;

void insert(int element){
    if(root==NULL){
        // Assigning first element of array as root
        root = node_new(element);
        return;
    }
    struct node* current = root;
    // We start traversal to insertion position from root
    while(1){
        if(element<current->val){
            // If the value is lesser we find in left subtree where to insert
            if(current->left==NULL){
                printf("Inserting %d in left of %d\n",element,current->val);
                current->left = node_new(element);
                break;
                // End the loop when insertion is done
            }
            else{
                // Repeat the process for left subtree which is also a BST
                current=current->left;
            }
        }
        else{
            if(current->right==NULL){
                printf("Inserting %d in right of %d\n",element,current->val);
                current->right = node_new(element);
                break;
            }
            else{
                current=current->right;
            }
        }
    }
}

int main() {
    int arr[] = {8,3,10,1,6,14};
    root=NULL;
    for(int i=0 ; i<6 ; i++){
        insert(arr[i]);
    }
    printf("The BST is created!");
    return 0;
}

79. Search in BST

// Definition of the tree node
/*
struct Node {
    int val;
    struct Node* left;
    struct Node* right;
};
*/

// Function to search a value in the BST
bool searchInBST(struct Node* root, int x) {
    if (root == NULL) {
        return false;
    }

    if (root->val == x) {
        return true;
    }

    if (root->val < x) {
        return searchInBST(root->right, x);
    } else {
        return searchInBST(root->left, x);
    }
}


80. Print nodes in sorted order


/*
struct Node {
    int val;
    struct Node* left;
    struct Node* right;
};
*/
void printSortedNodes(struct Node* root) {
    if (root == NULL)
        return;
    printSortedNodes(root->left);
    printf("%d ", root->val);
    printSortedNodes(root->right);
}


81. Find maximum node in BST


int maxNodeInBST(Node* root) {
    Node* current = root;
    while (current->right != NULL) {
        current = current->right;
    }
    return current->val;
}


82. Create BST from given sorted array


/* Paste only this into your existing file (assumes Node is already declared) */
Node* createBST(int* nums, int left, int right) {
    if (left > right) return NULL;
    int mid = left + (right - left) / 2;
    Node* root = (Node*)malloc(sizeof(*root));
    if (!root) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    root->val = nums[mid];
    root->left = createBST(nums, left, mid - 1);
    root->right = createBST(nums, mid + 1, right);
    return root;
}


83. Min Difference in BST

void printMinDifference(Node* root) {
    if (!root) {
        printf("0\n");
        return;
    }

    int capacity = 128;
    Node **stack = (Node**)malloc(sizeof(Node*) * capacity);
    if (!stack) { fprintf(stderr, "Memory allocation failed\n"); exit(EXIT_FAILURE); }
    int top = -1;
    Node *cur = root;

    int prevVal = 0;
    int minDiff = 2147483647; /* INT_MAX */
    int hasPrev = 0;

    while (cur != NULL || top != -1) {
        while (cur != NULL) {
            if (top + 1 >= capacity) {
                capacity *= 2;
                stack = (Node**)realloc(stack, sizeof(Node*) * capacity);
                if (!stack) { fprintf(stderr, "Memory allocation failed\n"); exit(EXIT_FAILURE); }
            }
            stack[++top] = cur;
            cur = cur->left;
        }
        cur = stack[top--];

        if (hasPrev) {
            int diff = cur->val - prevVal;
            if (diff < minDiff) minDiff = diff;
        } else {
            hasPrev = 1;
        }
        prevVal = cur->val;

        cur = cur->right;
    }

    free(stack);

    /* If tree had only one node, minDiff will remain INT_MAX — print 0 or appropriate value.
       Problem statement expects a numeric difference; with one node there's no pair — printing 0 is common. */
    if (minDiff == 2147483647) minDiff = 0;
    printf("%d\n", minDiff);
}


84. Check for BST

#include <stdio.h>
#include <limits.h>
#include <stdbool.h>

/* Recursive helper to validate BST */
bool isBSTUtil(Node* root, long long minVal, long long maxVal) {
    if (!root) return true;

    if (root->val <= minVal || root->val >= maxVal)
        return false;

    return isBSTUtil(root->left, minVal, root->val) &&
           isBSTUtil(root->right, root->val, maxVal);
}

/* Main function to check BST and print YES/NO */
void isBST(Node* root) {
    if (isBSTUtil(root, LLONG_MIN, LLONG_MAX))
        printf("YES\n");
    else
        printf("NO\n");
}


85. Kth Largest Node in BST


#include <stdio.h>

int kthLargestNodeUtil(Node* root, int k, int* count) {
    if (!root) return -1;  // placeholder, will be overwritten by kth node

    // Traverse right subtree first (larger values)
    int val = kthLargestNodeUtil(root->right, k, count);
    if (*count == k) return val;  // early return if kth found

    (*count)++;
    if (*count == k) return root->val;

    // Traverse left subtree
    return kthLargestNodeUtil(root->left, k, count);
}

int kthLargestNode(Node* root, int k) {
    int count = 0;
    return kthLargestNodeUtil(root, k, &count);
}



86. Predecessor of a Node in BST


/*
struct Node {
    int val; 
    Node *left;
    Node *right;

    Node(int node_value) {
        val = node_value;
        left = right = NULL;
    }
}; 
*/

class Solution {
  public:
    int getPredecessor(Node* root, int x) {
        Node* predecessor = nullptr;
        Node* curr = root;
        
        while (curr) {
            if (x > curr->val) {
                predecessor = curr;    // possible predecessor
                curr = curr->right;
            } else if (x < curr->val) {
                curr = curr->left;
            } else {
                // Node found, check left subtree
                if (curr->left) {
                    Node* temp = curr->left;
                    while (temp->right)
                        temp = temp->right;
                    predecessor = temp;
                }
                break;
            }
        }
        
        return predecessor ? predecessor->val : -1;
    }
};


87. Delete a Node in BST

Node* findMin(Node* root) {
    while (root && root->left != NULL)
        root = root->left;
    return root;
}

Node* deleteNode(Node* root, int x) {
    if (root == NULL) return NULL;

    if (x < root->val) {
        root->left = deleteNode(root->left, x);
    } else if (x > root->val) {
        root->right = deleteNode(root->right, x);
    } else {
        // Node found
        if (root->left == NULL) {
            Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            Node* temp = root->left;
            free(root);
            return temp;
        } else {
            // Node with two children
            Node* temp = findMin(root->right);
            root->val = temp->val;
            root->right = deleteNode(root->right, temp->val);
        }
    }
    return root;
}



88. BST Two Sum

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Assumes Node is already defined:
// typedef struct Node {
//     int val;
//     struct Node* left;
//     struct Node* right;
// } Node;

// Inorder traversal to store BST values in sorted order
void inorder(Node* root, int* arr, int* idx) {
    if (!root) return;
    inorder(root->left, arr, idx);
    arr[(*idx)++] = root->val;
    inorder(root->right, arr, idx);
}

// Two Sum using two pointers
void twoSumBST(Node* root, int S) {
    if (!root) {
        printf("NO\n");
        return;
    }

    int arr[10001]; // max nodes = 10000
    int n = 0;
    inorder(root, arr, &n);

    int i = 0, j = n - 1;
    while (i < j) {
        int sum = arr[i] + arr[j];
        if (sum == S) {
            printf("YES\n");
            return;
        } else if (sum < S) {
            i++;
        } else {
            j--;
        }
    }
    printf("NO\n");
}


89.Recover the BST


// Assumes struct TreeNode is already defined:
// struct TreeNode {
//     int value;
//     struct TreeNode* left;
//     struct TreeNode* right;
// };

// Helper function to perform inorder traversal and find swapped nodes
void inorderRecover(struct TreeNode* root, struct TreeNode** first, struct TreeNode** second, struct TreeNode** prev) {
    if (!root) return;

    inorderRecover(root->left, first, second, prev);

    if (*prev && (*prev)->value > root->value) {
        if (!*first) {
            *first = *prev;       // first node in the wrong position
        }
        *second = root;           // second node in the wrong position
    }

    *prev = root;

    inorderRecover(root->right, first, second, prev);
}

// Function to recover the BST
struct TreeNode* recoverBinarySearchTree(struct TreeNode* root) {
    struct TreeNode* first = NULL;
    struct TreeNode* second = NULL;
    struct TreeNode* prev = NULL;

    inorderRecover(root, &first, &second, &prev);

    if (first && second) {
        // Swap the values to fix the BST
        int temp = first->value;
        first->value = second->value;
        second->value = temp;
    }

    return root;
}



90. LCA in the BST

Node* lcaInBST(Node* root, int p, int q) {
    if (!root) return NULL;

    // If both nodes are smaller than root, LCA is in left subtree
    if (p < root->val && q < root->val) {
        return lcaInBST(root->left, p, q);
    }

    // If both nodes are greater than root, LCA is in right subtree
    if (p > root->val && q > root->val) {
        return lcaInBST(root->right, p, q);
    }

    // Otherwise, root is split point, so it's the LCA
    return root;
}


91. Graph Implementation - Adjacency 


#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
   cin >> n >> m;
    vector<int> graph[n + 1]; // 1-based node indexing
    // There are no elements currently in any list
    // Below is our input edges
    for(int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    for(int i = 1 ; i <= n ; i++){
        for(int j = 0 ; j < graph[i].size(); j++){
            cout << graph[i][j] << " ";
        }
        cout<<"\n";
    }
    return 0;
}


92. Graph Implementation - Adjacency Matrix


#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;

    // This is our adjacency matrix
    // All the elements are initialized to zero
    vector < vector < int >> adjMatrix(n + 1, vector < int > (n + 1, 0));

    // Take the input for all the edges
    int u, v;
    for (int i = 0; i < m; i++) {
        cin >> u >> v;

        // Adding an edge from u to v
        adjMatrix[u][v] = 1; 
        adjMatrix[v][u] = 1;
    }

    // Printing the adjacency matrix
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << adjMatrix[i][j] << " ";
        }
        cout << "\n";
    }
}


93. DFS on Graph


#include <iostream>
#include <vector>
#include <stack>

using namespace std;

// Function to perform DFS
void dfs(int node, vector<bool>& visited, vector<vector<int>>& adjList) {
    // Mark the current node as visited
    visited[node] = true;
    
    // Process the current node (print or do other operations)
    cout << node << " ";

    // Explore all unvisited neighbors
    for (int neighbor : adjList[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, visited, adjList);
        }
    }
}

// Function to initialize DFS and handle disconnected components
void performDFS(int numNodes, vector<vector<int>>& adjList) {
    vector<bool> visited(numNodes + 1, false);

    // Iterate through all nodes to handle disconnected components
    for (int i = 1; i <= numNodes; ++i) {
        if (!visited[i]) {
            dfs(i, visited, adjList);
        }
    }
}

int main() {
   
    int numNodes, numEdges;
    cin >> numNodes >>  numEdges;
    vector<vector<int>> adjList(numNodes + 1);

    // Adding edges to the graph
    for(int i = 0; i < numEdges; i++) {
        int u, v;
        cin >> u >> v;
       adjList[u].push_back(v);
       adjList[v].push_back(u);
    }

    // Perform DFS
    cout << "DFS traversal: ";
    performDFS(numNodes, adjList);

    return 0;
}


94.  BFS on Graph

#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// Function to perform BFS
void bfs(int start, vector<bool>& visited, vector<vector<int>>& adjList) {
    queue<int> q;
    q.push(start);
    visited[start] = true;

    // Process nodes in the queue
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";

        // Enqueue unvisited neighbors
        for (int neighbor : adjList[node]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}

int main() {
    int numNodes, numEdges;
    cin >> numNodes >>  numEdges;
    vector<vector<int>> adjList(numNodes + 1);

    // Adding edges to the graph
    for(int i = 0; i < numEdges; i++) {
        int u, v;
        cin >> u >> v;
       adjList[u].push_back(v);
       adjList[v].push_back(u);
    }

    // Perform BFS starting from node 1
    vector<bool> visited(numNodes + 1, false);
    cout << "BFS traversal: ";
    bfs(1, visited, adjList);

    return 0;
}

95.Check Reachability

#include <stdio.h>
#include <stdlib.h>

#define MAXN 200005

// Adjacency list representation
typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

Node* adj[MAXN];
int visited[MAXN];

// Function to create a new node
Node* createNode(int v) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

// Add edge to graph
void addEdge(int u, int v) {
    Node* newNode = createNode(v);
    newNode->next = adj[u];
    adj[u] = newNode;
}

// Depth First Search (DFS)
void dfs(int node) {
    visited[node] = 1;
    Node* temp = adj[node];
    while (temp != NULL) {
        if (!visited[temp->vertex])
            dfs(temp->vertex);
        temp = temp->next;
    }
}

int main() {
    int N, M;
    scanf("%d %d", &N, &M);

    // Initialize adjacency list
    for (int i = 1; i <= N; i++)
        adj[i] = NULL;

    // Read edges
    for (int i = 0; i < M; i++) {
        int A, B;
        scanf("%d %d", &A, &B);
        addEdge(A, B);
    }

    // Run DFS from node 1
    dfs(1);

    // Print reachable vertices in increasing order
    for (int i = 1; i <= N; i++) {
        if (visited[i])
            printf("%d ", i);
    }
    printf("\n");

    return 0;
}


96. Chef Shortest Route


#include <stdio.h>
#include <stdlib.h>

#define MAXN 200005

// Adjacency list structure
typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

Node* adj[MAXN];
int visited[MAXN];
int dist[MAXN];

// Function to create a new node
Node* createNode(int v) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

// Add edge to the graph (undirected)
void addEdge(int u, int v) {
    Node* newNode = createNode(v);
    newNode->next = adj[u];
    adj[u] = newNode;

    newNode = createNode(u);
    newNode->next = adj[v];
    adj[v] = newNode;
}

// BFS function to find shortest path from 1 to N
int bfs(int N) {
    int queue[MAXN];
    int front = 0, rear = 0;

    visited[1] = 1;
    dist[1] = 1; // number of servers (nodes) in path, starting at 1
    queue[rear++] = 1;

    while (front < rear) {
        int node = queue[front++];
        Node* temp = adj[node];

        while (temp != NULL) {
            int v = temp->vertex;
            if (!visited[v]) {
                visited[v] = 1;
                dist[v] = dist[node] + 1;
                queue[rear++] = v;
                if (v == N)
                    return dist[v]; // stop early when we reach Chefina
            }
            temp = temp->next;
        }
    }

    return -1; // no route found
}

int main() {
    int N, M;
    scanf("%d %d", &N, &M);

    // Initialize adjacency list
    for (int i = 1; i <= N; i++) {
        adj[i] = NULL;
        visited[i] = 0;
        dist[i] = 0;
    }

    // Read connections
    for (int i = 0; i < M; i++) {
        int a, b;
        scanf("%d %d", &a, &b);
        addEdge(a, b);
    }

    int result = bfs(N);
    printf("%d\n", result);

    return 0;
}



97. Minimum Distance Between Two Nodes


#include <bits/stdc++.h>

using namespace std;



int main() {

    ios::sync_with_stdio(false);

    cin.tie(nullptr);



    int N, M;

    cin >> N >> M;



    vector<vector<int>> adj(N + 1);



    // Read edges

    for (int i = 0; i < M; i++) {

        int u, v;

        cin >> u >> v;

        adj[u].push_back(v);

        adj[v].push_back(u); // undirected graph

    }



    int x, y;

    cin >> x >> y;



    // BFS to find shortest distance

    vector<int> dist(N + 1, -1);

    queue<int> q;



    dist[x] = 0; // distance from x to itself is 0

    q.push(x);



    while (!q.empty()) {

        int node = q.front();

        q.pop();



        for (int neighbor : adj[node]) {

            if (dist[neighbor] == -1) {

                dist[neighbor] = dist[node] + 1;

                q.push(neighbor);

            }

        }

    }



    cout << dist[y] << "\n"; // distance between x and y (or -1 if unreachable)

    return 0;

}


98. Algorithm description


#include <stdio.h>

#include <limits.h>

#include <stdbool.h>



#define MAX 1000

#define INF INT_MAX



int findMinVertex(int dist[], bool visited[], int n) {

    int minVertex = -1;

    for (int i = 0; i < n; i++) {

        if (!visited[i] && (minVertex == -1 || dist[i] < dist[minVertex])) {

            minVertex = i;

        }

    }

    return minVertex;

}



int main() {

    int n, m;

    scanf("%d %d", &n, &m);



    int source;

    scanf("%d", &source);

    source--; // convert to 0-based indexing



    int graph[MAX][MAX];



    // Initialize graph with INF

    for (int i = 0; i < n; i++) {

        for (int j = 0; j < n; j++) {

            graph[i][j] = INF;

        }

    }



    // Read edges

    for (int i = 0; i < m; i++) {

        int u, v, w;

        scanf("%d %d %d", &u, &v, &w);

        u--; v--;

        graph[u][v] = w;

        graph[v][u] = w; // since graph is undirected

    }



    int dist[MAX];

    bool visited[MAX];



    // Initialize distances

    for (int i = 0; i < n; i++) {

        dist[i] = INF;

        visited[i] = false;

    }



    dist[source] = 0;



    // Dijkstra's Algorithm

    for (int i = 0; i < n - 1; i++) {

        int minVertex = findMinVertex(dist, visited, n);

        visited[minVertex] = true;



        for (int j = 0; j < n; j++) {

            if (graph[minVertex][j] != INF && !visited[j]) {

                int newDist = dist[minVertex] + graph[minVertex][j];

                if (newDist < dist[j]) {

                    dist[j] = newDist;

                }

            }

        }

    }



    // Print shortest distances

    for (int i = 0; i < n; i++) {

        if (dist[i] == INF)

            printf("INF ");

        else

            printf("%d ", dist[i]);

    }



    printf("\n");

    return 0;

}


99. Single Source Shortest Path

#include <stdio.h>

#include <limits.h>

#include <stdbool.h>



#define MAX 1005

#define INF LLONG_MAX



long long graph[MAX][MAX];

long long dist[MAX];

bool visited[MAX];



int findMinVertex(int n) {

    int minVertex = -1;

    for (int i = 1; i <= n; i++) {

        if (!visited[i] && (minVertex == -1 || dist[i] < dist[minVertex])) {

            minVertex = i;

        }

    }

    return minVertex;

}



int main() {

    int N, M;

    scanf("%d %d", &N, &M);



    // Initialize graph with infinity

    for (int i = 1; i <= N; i++) {

        for (int j = 1; j <= N; j++) {

            graph[i][j] = INF;

        }

    }



    // Read edges (undirected)

    for (int i = 0; i < M; i++) {

        int u, v;

        long long w;

        scanf("%d %d %lld", &u, &v, &w);

        if (w < graph[u][v]) { // keep the smallest weight if multiple edges exist

            graph[u][v] = w;

            graph[v][u] = w;

        }

    }



    // Initialize distance and visited arrays

    for (int i = 1; i <= N; i++) {

        dist[i] = INF;

        visited[i] = false;

    }



    // Source node = 1

    dist[1] = 0;



    // Dijkstra's Algorithm

    for (int i = 1; i <= N - 1; i++) {

        int u = findMinVertex(N);

        if (u == -1) break; // no more reachable vertices

        visited[u] = true;



        for (int v = 1; v <= N; v++) {

            if (graph[u][v] != INF && !visited[v] && dist[u] != INF) {

                long long newDist = dist[u] + graph[u][v];

                if (newDist < dist[v]) {

                    dist[v] = newDist;

                }

            }

        }

    }



    // Output distances

    for (int i = 1; i <= N; i++) {

        if (dist[i] == INF)

            printf("-1 ");

        else

            printf("%lld ", dist[i]);

    }

    printf("\n");



    return 0;

}



100. Priority Queue Approach

#include <stdio.h>

#include <stdbool.h>

#include <limits.h>



#define N 11

#define INF 1000000000000000000LL



long long d[N];

int adj[N][N]; // Adjacency matrix

bool vis[N];



void dijkstra(int source, int n) {

    for (int i = 1; i <= n; i++) {

        d[i] = INF;

        vis[i] = false;

    }

    d[source] = 0;



    // Create priority queue using min heap

    int pq_size = 0;

    int pq[N]; // Priority queue storing nodes

    pq[pq_size++] = source;



    while (pq_size != 0) {

        // Find the node with minimum distance

        int min_distance = INT_MAX;

        int min_index = -1;

        for (int i = 0; i < pq_size; i++) {

            if (d[pq[i]] < min_distance && !vis[pq[i]]) {

                min_distance = d[pq[i]];

                min_index = i;

            }

        }



        if (min_index == -1) break;



        int v = pq[min_index];

        pq[min_index] = pq[--pq_size]; // Remove the min node from pq

        vis[v] = true;



        printf("Processing vertex: %d\n", v);



        for (int i = 1; i <= n; i++) {

            if (adj[v][i] != 0) {

                int u = i;

                int weight = adj[v][i];



                // Update the distance of the vertex

                if (d[u] > d[v] + weight) {

                    d[u] = d[v] + weight;

                }



                // Store the new node in the priority queue

                pq[pq_size++] = u;

            }

        }

    }

}



// Function to add an edge between two vertices with a given weight

void addEdge(int u, int v, int weight) {

    adj[u][v] = weight;

    adj[v][u] = weight; // Assuming the graph is undirected

}



int main() {

    // Building adjacency list for Undirected Graph

    addEdge(1, 2, 4);

    addEdge(1, 3, 2);

    addEdge(1, 4, 6);



    addEdge(2, 1, 4);

    addEdge(2, 4, 1);

    addEdge(2, 6, 3);



    addEdge(3, 1, 2);

    addEdge(3, 5, 10);



    addEdge(4, 1, 6);

    addEdge(4, 2, 1);



    addEdge(5, 3, 10);

    addEdge(5, 6, 4);



    addEdge(6, 2, 3);

    addEdge(6, 5, 4);



    dijkstra(1, 6); // Start dijkstra with source as 1

    printf("\n");



    for (int i = 1; i <= 6; i++) {

        printf("Distance of Vertex %d: %lld\n", i, d[i]);

    }



    return 0;

}



101. Single Source Shortest Path


#include <stdio.h>

#include <stdlib.h>

#include <limits.h>



// Define a structure for an edge

typedef struct Edge {

    int to;

    long long weight;

    struct Edge* next;

} Edge;



// Define a structure for a node in the priority queue (for Dijkstra)

typedef struct PQNode {

    long long distance;

    int vertex;

} PQNode;



// Global array to store the distance from the source (vertex 1)

long long dist[200005];



// Global array for adjacency list: adj[i] points to the head of the linked list of edges from vertex i

Edge* adj[200005];



// Global array for the priority queue (implemented as a min-heap)

PQNode pq[400005];

int pq_size = 0;



// --- Priority Queue (Min-Heap) Helper Functions ---



// Function to swap two PQNode elements

void swap_pq_node(int i, int j) {

    PQNode temp = pq[i];

    pq[i] = pq[j];

    pq[j] = temp;

}



// Function to "heapify up" after insertion

void pq_push_up(int index) {

    int parent = (index - 1) / 2;

    while (index > 0 && pq[index].distance < pq[parent].distance) {

        swap_pq_node(index, parent);

        index = parent;

        parent = (index - 1) / 2;

    }

}



// Function to "heapify down" after extraction

void pq_push_down(int index) {

    int left_child = 2 * index + 1;

    int right_child = 2 * index + 2;

    int smallest = index;



    if (left_child < pq_size && pq[left_child].distance < pq[smallest].distance) {

        smallest = left_child;

    }

    if (right_child < pq_size && pq[right_child].distance < pq[smallest].distance) {

        smallest = right_child;

    }



    if (smallest != index) {

        swap_pq_node(index, smallest);

        pq_push_down(smallest);

    }

}



// Function to insert a node into the priority queue

void pq_insert(long long distance, int vertex) {

    pq[pq_size].distance = distance;

    pq[pq_size].vertex = vertex;

    pq_push_up(pq_size);

    pq_size++;

}



// Function to extract the minimum node (root) from the priority queue

PQNode pq_extract_min() {

    if (pq_size == 0) {

        // Should not happen if the algorithm is correct

        return (PQNode){-1, -1};

    }

    PQNode min_node = pq[0];

    pq_size--;

    if (pq_size > 0) {

        pq[0] = pq[pq_size];

        pq_push_down(0);

    }

    return min_node;

}



// --- Graph and Dijkstra's Algorithm ---



// Function to add an undirected edge to the adjacency list

void add_edge(int u, int v, long long w) {

    // Edge u -> v

    Edge* edge_uv = (Edge*)malloc(sizeof(Edge));

    edge_uv->to = v;

    edge_uv->weight = w;

    edge_uv->next = adj[u];

    adj[u] = edge_uv;



    // Edge v -> u (since it's an undirected graph)

    Edge* edge_vu = (Edge*)malloc(sizeof(Edge));

    edge_vu->to = u;

    edge_vu->weight = w;

    edge_vu->next = adj[v];

    adj[v] = edge_vu;

}



// Function implementing Dijkstra's Algorithm

void dijkstra(int N, int start_vertex) {

    // 1. Initialization

    for (int i = 1; i <= N; i++) {

        dist[i] = LLONG_MAX; // Use a large value to represent infinity

    }



    // Distance to the source is 0

    dist[start_vertex] = 0;

    pq_insert(0, start_vertex);



    // 2. Main loop

    while (pq_size > 0) {

        PQNode current = pq_extract_min();

        long long d = current.distance;

        int u = current.vertex;



        // Optimization: If the extracted distance is greater than the currently known shortest distance, skip

        if (d > dist[u]) {

            continue;

        }



        // 3. Relaxation: Check all neighbors v of u

        Edge* current_edge = adj[u];

        while (current_edge != NULL) {

            int v = current_edge->to;

            long long weight = current_edge->weight;



            // Relaxation step: dist[u] + weight < dist[v]

            if (dist[u] != LLONG_MAX && dist[u] + weight < dist[v]) {

                dist[v] = dist[u] + weight;

                pq_insert(dist[v], v); // Push the new shorter path to the priority queue

            }

            current_edge = current_edge->next;

        }

    }

}



int main() {

    int N, M;

    // Fast input reading

    if (scanf("%d %d", &N, &M) != 2) return 1;



    // Initialize adjacency list

    for (int i = 1; i <= N; i++) {

        adj[i] = NULL;

    }



    // Read edges

    for (int i = 0; i < M; i++) {

        int u, v;

        long long w;

        if (scanf("%d %d %lld", &u, &v, &w) != 3) return 1;

        add_edge(u, v, w);

    }



    // Run Dijkstra's algorithm from vertex 1

    dijkstra(N, 1);



    // Output the results

    for (int i = 1; i <= N; i++) {

        if (dist[i] == LLONG_MAX) {

            printf("-1");

        } else {

            // Note: The problem constraints suggest that edge weights up to 10^9 and N up to 2*10^5 

            // could result in shortest path distances up to 2*10^5 * 10^9 = 2*10^14.

            // This is why a 'long long' (64-bit integer) is necessary for distance.

            printf("%lld", dist[i]);

        }

        if (i < N) {

            printf(" ");

        }

    }

    printf("\n");



    // Clean up allocated memory for the adjacency list

    for (int i = 1; i <= N; i++) {

        Edge* current = adj[i];

        while (current != NULL) {

            Edge* temp = current;

            current = current->next;

            free(temp);

        }

    }



    return 0;

}



102. Minimum Cost Walk


#include <stdio.h>

#include <stdlib.h>

#include <limits.h>



typedef long long ll;

const ll INF = (ll)9e18;



typedef struct Edge {

    int to;

    ll w;

    struct Edge *next;

} Edge;



/* Min-heap node */

typedef struct {

    ll dist;

    int node;

} HNode;



Edge **adj;       // adjacency list (1-indexed)

ll *distS, *distT, *distV;

int *vis;

HNode *heap;      // binary min-heap

int heapCap;



void push_heap(int *hsize, HNode val) {

    if (*hsize + 1 >= heapCap) {

        // expand heap if necessary

        heapCap *= 2;

        heap = realloc(heap, sizeof(HNode) * heapCap);

        if (!heap) { fprintf(stderr, "heap realloc failed\n"); exit(1); }

    }

    int i = ++(*hsize);

    while (i > 1 && heap[i/2].dist > val.dist) {

        heap[i] = heap[i/2];

        i /= 2;

    }

    heap[i] = val;

}



HNode pop_heap(int *hsize) {

    HNode ret = heap[1];

    HNode last = heap[(*hsize)--];

    int i = 1, j = 2;

    while (j <= *hsize) {

        if (j < *hsize && heap[j+1].dist < heap[j].dist) j++;

        if (last.dist <= heap[j].dist) break;

        heap[i] = heap[j];

        i = j; j <<= 1;

    }

    heap[i] = last;

    return ret;

}



void addEdge(int u, int v, ll w) {

    Edge *e = malloc(sizeof(Edge));

    e->to = v; e->w = w; e->next = adj[u]; adj[u] = e;

}



void dijkstra(int n, int start, ll *dist) {

    for (int i = 1; i <= n; ++i) {

        dist[i] = INF;

        vis[i] = 0;

    }

    int hsize = 0;

    dist[start] = 0;

    push_heap(&hsize, (HNode){0, start});

    while (hsize > 0) {

        HNode hn = pop_heap(&hsize);

        int u = hn.node;

        if (vis[u]) continue;

        vis[u] = 1;

        for (Edge *e = adj[u]; e; e = e->next) {

            int v = e->to;

            ll nd = dist[u] + e->w;

            if (nd < dist[v]) {

                dist[v] = nd;

                push_heap(&hsize, (HNode){nd, v});

            }

        }

    }

}



void clearGraph(int n) {

    for (int i = 1; i <= n; ++i) {

        Edge *cur = adj[i];

        while (cur) {

            Edge *tmp = cur;

            cur = cur->next;

            free(tmp);

        }

        adj[i] = NULL;

    }

}



int main() {

    ios: ;

    int t;

    if (scanf("%d", &t)!=1) return 0;



    while (t--) {

        int N, M;

        if (scanf("%d %d", &N, &M)!=2) return 0;

        int S, T, V;

        scanf("%d %d %d", &S, &T, &V);



        // allocate structures sized to N

        adj = calloc(N+1, sizeof(Edge*));

        distS = malloc(sizeof(ll)*(N+1));

        distT = malloc(sizeof(ll)*(N+1));

        distV = malloc(sizeof(ll)*(N+1));

        vis   = malloc(sizeof(int)*(N+1));



        // heap capacity approximate (M relaxations possible) + margin

        heapCap = (M+5) * 4;

        if (heapCap < 1024) heapCap = 1024;

        heap = malloc(sizeof(HNode) * heapCap);



        for (int i = 0; i < M; ++i) {

            int a, b;

            ll c;

            scanf("%d %d %lld", &a, &b, &c);

            addEdge(a, b, c);

            addEdge(b, a, c);

        }



        // run dijkstra from S, T, V

        dijkstra(N, S, distS);

        dijkstra(N, T, distT);

        dijkstra(N, V, distV);



        // find minimum sum over x

        ll answer = INF;

        for (int x = 1; x <= N; ++x) {

            if (distS[x] == INF || distT[x] == INF || distV[x] == INF) continue;

            ll sum = distS[x] + distT[x] + distV[x];

            if (sum < answer) answer = sum;

        }



        // print answer

        if (answer == INF) printf("-1\n");

        else printf("%lld\n", answer);



        // free

        clearGraph(N);

        free(adj);

        free(distS);

        free(distT);

        free(distV);

        free(vis);

        free(heap);

    }



    return 0;

}


103. Planetary Path


#include <stdio.h>

#include <stdlib.h>

#include <limits.h>



#define INF 1000000000000000000LL



typedef long long ll;



typedef struct Edge {

    int to;

    ll w;

    struct Edge *next;

} Edge;



typedef struct {

    ll dist;

    int node;

} HeapNode;



Edge **adj;

ll *dist;

int *vis;



HeapNode *heap;

int heapSize = 0, heapCap;



void push(HeapNode val) {

    if (heapSize + 1 >= heapCap) {

        heapCap *= 2;

        heap = realloc(heap, heapCap * sizeof(HeapNode));

    }

    int i = ++heapSize;

    while (i > 1 && heap[i / 2].dist > val.dist) {

        heap[i] = heap[i / 2];

        i /= 2;

    }

    heap[i] = val;

}



HeapNode pop() {

    HeapNode top = heap[1];

    HeapNode last = heap[heapSize--];

    int i = 1, j = 2;

    while (j <= heapSize) {

        if (j < heapSize && heap[j + 1].dist < heap[j].dist) j++;

        if (last.dist <= heap[j].dist) break;

        heap[i] = heap[j];

        i = j; j <<= 1;

    }

    heap[i] = last;

    return top;

}



void addEdge(int u, int v, ll w) {

    Edge *e = malloc(sizeof(Edge));

    e->to = v; e->w = w;

    e->next = adj[u]; adj[u] = e;

}



void dijkstra(int start, int total) {

    for (int i = 1; i <= total; i++) {

        dist[i] = INF;

        vis[i] = 0;

    }

    heapSize = 0;

    dist[start] = 0;

    push((HeapNode){0, start});

    while (heapSize > 0) {

        HeapNode h = pop();

        int u = h.node;

        if (vis[u]) continue;

        vis[u] = 1;

        for (Edge *e = adj[u]; e; e = e->next) {

            int v = e->to;

            if (dist[v] > dist[u] + e->w) {

                dist[v] = dist[u] + e->w;

                push((HeapNode){dist[v], v});

            }

        }

    }

}



void clearGraph(int n) {

    for (int i = 1; i <= n; i++) {

        Edge *cur = adj[i];

        while (cur) {

            Edge *tmp = cur;

            cur = cur->next;

            free(tmp);

        }

        adj[i] = NULL;

    }

}



int main() {

    int N, K, S;

    scanf("%d %d %d", &N, &K, &S);



    int *A = malloc((N + 1) * sizeof(int));

    for (int i = 1; i <= N; i++) scanf("%d", &A[i]);



    int total = N + K;

    adj = calloc(total + 1, sizeof(Edge *));

    dist = malloc((total + 1) * sizeof(ll));

    vis = malloc((total + 1) * sizeof(int));

    heapCap = 4 * (N + K) + 10;

    heap = malloc(heapCap * sizeof(HeapNode));



    ll **C = malloc((N + 1) * sizeof(ll *));

    for (int i = 1; i <= N; i++) {

        C[i] = malloc((K + 1) * sizeof(ll));

        for (int j = 1; j <= K; j++) {

            scanf("%lld", &C[i][j]);

            if (C[i][j] >= 0) {

                addEdge(i, N + j, C[i][j]);

            }

        }

    }



    // Add alliance -> planet edges (free travel within same alliance)

    for (int i = 1; i <= N; i++) {

        addEdge(N + A[i], i, 0);

    }



    // Dijkstra from planet S

    dijkstra(S, total);



    // Output distances for planets 1..N

    for (int i = 1; i <= N; i++) {

        if (dist[i] >= INF / 2) printf("-1 ");

        else printf("%lld ", dist[i]);

    }

    printf("\n");



    // cleanup

    clearGraph(total);

    for (int i = 1; i <= N; i++) free(C[i]);

    free(C);

    free(A);

    free(adj);

    free(dist);

    free(vis);

    free(heap);



    return 0;

}


104. Real life implementation


#include <stdio.h>

int main() {
    int array[] = {3, 5, 2, 9, 7, 1};
    int length = sizeof(array) / sizeof(array[0]);

    // Linear search for 7
    for (int i = 0; i < length; i++) {
        if (array[i] == 7) {
            printf("Yes\n");
            return 0; // Exit immediately after finding 7
        }
    }

    // If 7 is not found
    printf("No\n");
    return 0;
}


105. Linear Search in array


#include <stdio.h>

int main() {
    int n, k;
    scanf("%d %d", &n, &k);  // Read array size and element to search

    int array[n];
    for (int i = 0; i < n; i++) {
        scanf("%d", &array[i]);  // Read array elements
    }

    // Linear search
    for (int i = 0; i < n; i++) {
        if (array[i] == k) {
            printf("Yes\n");
            return 0;  // Exit immediately if element is found
        }
    }

    // If element not found
    printf("No\n");
    return 0;
}


106. Linear Search in string



#include <stdio.h>
#include <string.h>

int main() {
    char str[100], ch;
    int i, found = -1;

    // Input string
    scanf("%s", str);

    // Input character to search
    scanf(" %c", &ch); // space before %c to ignore newline

    // Linear search in string
    for (i = 0; str[i] != '\0'; i++) {
        if (str[i] == ch) {
            found = i;
            break;
        }
    }

    // Output result
    printf("%d\n", found);

    return 0;
}


107. Miscellaneous Linear Search

#include <stdio.h>

int main() {
    int n, a, b, x, y, i, found = 0;

    // Input number of pairs
    scanf("%d", &n);

    int arr[n][2];

    // Input the pairs
    for (i = 0; i < n; i++) {
        scanf("%d %d", &arr[i][0], &arr[i][1]);
    }

    // Input the target pair (a, b)
    scanf("%d %d", &a, &b);

    // Linear search to find if any pair contains both a and b (in any order)
    for (i = 0; i < n; i++) {
        x = arr[i][0];
        y = arr[i][1];

        if ((x == a && y == b) || (x == b && y == a)) {
            found = 1;
            break;
        }
    }

    // Output result
    if (found)
        printf("Yes\n");
    else
        printf("No\n");

    return 0;
}


108. Find Kth Character Position


#include <stdio.h>
#include <string.h>

int main() {
    char s1[100], c1;
    int k, i, count = 0, pos = -1;

    // Input string, character, and integer k
    scanf("%s %c %d", s1, &c1, &k);

    // Traverse the string to find kth occurrence
    for (i = 0; s1[i] != '\0'; i++) {
        if (s1[i] == c1) {
            count++;
            if (count == k) {
                pos = i;
                break;
            }
        }
    }

    // Output position or -1 if not found
    printf("%d\n", pos);

    return 0;
}


109. Find smallest and largest numbers

#include <stdio.h>

int main() {
    int n, i;

    // Input number of elements
    scanf("%d", &n);

    int arr[n];

    // Input array elements
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Initialize smallest and largest as first element
    int smallest = arr[0];
    int largest = arr[0];

    // Find smallest and largest
    for (i = 1; i < n; i++) {
        if (arr[i] < smallest)
            smallest = arr[i];
        if (arr[i] > largest)
            largest = arr[i];
    }

    // Output result
    printf("%d %d\n", smallest, largest);

    return 0;
}



110. Find Smallest Absolute Difference


#include <stdio.h>
#include <stdlib.h>  // for abs()

int main() {
    int n, k, i;

    // Input size of array and the integer k
    scanf("%d %d", &n, &k);

    int arr[n];
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Initialize minimum difference and element
    int minDiff = abs(arr[0] - k);
    int result = arr[0];

    // Check all elements
    for (i = 1; i < n; i++) {
        int diff = abs(arr[i] - k);

        if (diff < minDiff) {
            minDiff = diff;
            result = arr[i];
        } else if (diff == minDiff && arr[i] < result) {
            // If same difference, choose smaller element
            result = arr[i];
        }
    }

    // Output the result
    printf("%d\n", result);

    return 0;
}



111. Find Pairs Divisible Sum



#include <stdio.h>

int main() {
    int n, k, i;
    int a, b;

    // Input number of pairs and divisor
    scanf("%d %d", &n, &k);

    // Loop through all pairs
    for (i = 0; i < n; i++) {
        scanf("%d %d", &a, &b);

        // Check if sum of pair is divisible by k
        if ((a + b) % k == 0) {
            printf("(%d, %d)\n", a, b);
        }
    }

    return 0;
}


112. Find Valid Pair


#include <stdio.h>

int main() {
    int n, i;
    int a, b, left, right;

    // Input number of pairs
    scanf("%d", &n);

    int arr[n][2];

    // Input n pairs
    for (i = 0; i < n; i++) {
        scanf("%d %d", &arr[i][0], &arr[i][1]);
    }

    // Input range [left, right]
    scanf("%d %d", &left, &right);

    // Process each pair
    for (i = 0; i < n; i++) {
        a = arr[i][0];
        b = arr[i][1];

        int sum = a + b;
        int product = a * b;

        // Check if both sum and product lie within [left, right]
        if (sum >= left && sum <= right && product >= left && product <= right) {
            printf("%d %d\n", a, b);
        }
    }

    return 0;
}


113. Sort three integer


#include <stdio.h>

int main() {
    int a, b, c, temp;

    // Input three integers
    scanf("%d %d %d", &a, &b, &c);

    // Compare and swap to sort manually
    if (a > b) {
        temp = a;
        a = b;
        b = temp;
    }

    if (a > c) {
        temp = a;
        a = c;
        c = temp;
    }

    if (b > c) {
        temp = b;
        b = c;
        c = temp;
    }

    // Print in ascending order
    printf("%d %d %d\n", a, b, c);

    return 0;
}


114. Implementation of Bubble Sort


#include <stdio.h>

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap arr[j] and arr[j + 1]
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[] = {6, 5, 3, 1, 8, 7, 2, 4};
    int n = sizeof(arr) / sizeof(arr[0]);
    bubbleSort(arr, n);
    printArray(arr, n);
    return 0;
}


115. Complete the implementation


void bubbleSort(int arr[], int n) {
    int i, j, temp;

    // Bubble Sort algorithm
    for (i = 0; i < n - 1; i++) {
        for (j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap arr[j] and arr[j + 1]
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}



116. NGE


#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n);
    int arr[n];
    int result[n];

    // Input array
    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    // Find Next Greater Element for each element
    for (int i = 0; i < n; i++) {
        int next = -1;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] > arr[i]) {
                next = arr[j];
                break;
            }
        }
        result[i] = next;
    }

    // Output results
    for (int i = 0; i < n; i++)
        printf("%d ", result[i]);

    return 0;
}


117. Complete the implementation


void selectionSort(int arr[], int n) {
    int i, j, minIndex, temp;

    // Loop through the entire array
    for (i = 0; i < n - 1; i++) {
        minIndex = i;  // assume the current index is the minimum

        // Find index of the smallest element in the unsorted part
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        // Swap the smallest found with the first unsorted element
        if (minIndex != i) {
            temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}



118. Complete the implementation


void insertionSort(int arr[], int n) {

    int i, key, j;

    for (i = 1; i < n; i++) {

        key = arr[i];

        j = i - 1;



        // Move elements that are greater than key to one position ahead

        while (j >= 0 && arr[j] > key) {

            arr[j + 1] = arr[j];

            j = j - 1;

        }

        arr[j + 1] = key;

    }

}


119. Merging


#include <stdio.h>

int main() {
    int n, m;
    scanf("%d", &n);
    int arr1[n];
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr1[i]);
    }

    scanf("%d", &m);
    int arr2[m];
    for (int i = 0; i < m; i++) {
        scanf("%d", &arr2[i]);
    }

    int merged[n + m];
    int i = 0, j = 0, k = 0;

    // Merge both arrays
    while (i < n && j < m) {
        if (arr1[i] <= arr2[j]) {
            merged[k++] = arr1[i++];
        } else {
            merged[k++] = arr2[j++];
        }
    }

    // Copy remaining elements
    while (i < n) {
        merged[k++] = arr1[i++];
    }

    while (j < m) {
        merged[k++] = arr2[j++];
    }

    // Print merged sorted array
    for (int x = 0; x < n + m; x++) {
        printf("%d ", merged[x]);
    }

    return 0;
}


120. Complete the implementation

void merge(int arr[], int left, int mid, int right) {

    int n1 = mid - left + 1;

    int n2 = right - mid;



    int L[n1], R[n2];

    for (int i = 0; i < n1; i++)

        L[i] = arr[left + i];

    for (int j = 0; j < n2; j++)

        R[j] = arr[mid + 1 + j];



    int i = 0, j = 0, k = left;



    // Merge the two halves into the original array

    while (i < n1 && j < n2) {

        if (L[i] <= R[j]) {

            arr[k++] = L[i++];

        } else {

            arr[k++] = R[j++];

        }

    }



    // Copy any remaining elements

    while (i < n1) {

        arr[k++] = L[i++];

    }

    while (j < n2) {

        arr[k++] = R[j++];

    }

}



void mergeSort(int arr[], int left, int right) {

    if (left < right) {

        int mid = (left + right) / 2;



        // Sort first and second halves

        mergeSort(arr, left, mid);

        mergeSort(arr, mid + 1, right);



        // Merge the sorted halves

        merge(arr, left, mid, right);

    }

}


121. Complete the implementation





int partition(int arr[], int low, int high) {

    int pivot = arr[high];  // choose the last element as pivot

    int i = (low - 1);

    int temp;



    for (int j = low; j < high; j++) {

        if (arr[j] < pivot) {

            i++;

            // swap arr[i] and arr[j]

            temp = arr[i];

            arr[i] = arr[j];

            arr[j] = temp;

        }

    }



    // swap arr[i+1] and arr[high] (pivot)

    temp = arr[i + 1];

    arr[i + 1] = arr[high];

    arr[high] = temp;



    return (i + 1);

}



void quickSort(int arr[], int low, int high) {

    if (low < high) {

        int pi = partition(arr, low, high);



        // Recursively sort elements before and after partition

        quickSort(arr, low, pi - 1);

        quickSort(arr, pi + 1, high);

    }

}


122. Complete the implementation


#include <stdio.h>



// A utility function to get the maximum value in the array

int getMax(int arr[], int n) {

    int max = arr[0];

    for (int i = 1; i < n; i++) {

        if (arr[i] > max)

            max = arr[i];

    }

    return max;

}



// A function to perform counting sort based on the digit represented by exp

void countingSort(int arr[], int n, int exp) {

    int output[n]; 

    int count[10] = {0};



    // Store count of occurrences in count[]

    for (int i = 0; i < n; i++)

        count[(arr[i] / exp) % 10]++;



    // Change count[i] so that count[i] contains actual position of this digit in output[]

    for (int i = 1; i < 10; i++)

        count[i] += count[i - 1];



    // Build the output array

    for (int i = n - 1; i >= 0; i--) {

        output[count[(arr[i] / exp) % 10] - 1] = arr[i];

        count[(arr[i] / exp) % 10]--;

    }



    // Copy the output array back to arr[]

    for (int i = 0; i < n; i++)

        arr[i] = output[i];

}



// Main function to implement Radix Sort

void radixSort(int arr[], int n) {

    int max = getMax(arr, n);



    // Apply counting sort for each digit (1s, 10s, 100s...)

    for (int exp = 1; max / exp > 0; exp *= 10)

        countingSort(arr, n, exp);

}


123. Frequency of each element in th

#include <stdio.h>



int main() {

    int T;

    scanf("%d", &T); // Number of test cases



    while (T--) {

        int N;

        scanf("%d", &N);

        int arr[N];



        for (int i = 0; i < N; i++) {

            scanf("%d", &arr[i]);

        }



        // For each element, count its frequency

        for (int i = 0; i < N; i++) {

            int count = 0;

            for (int j = 0; j < N; j++) {

                if (arr[i] == arr[j]) {

                    count++;

                }

            }

            printf("%d ", count);

        }

        printf("\n"); // Move to next line for next test case

    }



    return 0;

}


124. Frequency of elements using Has

#include <stdio.h>



int main() {

    int T;

    scanf("%d", &T); // number of test cases



    while (T--) {

        int N;

        scanf("%d", &N);

        int arr[N];

        int freq[101] = {0}; // Since max(A) ≤ 100, create hash array of size 101



        // Read the array elements

        for (int i = 0; i < N; i++) {

            scanf("%d", &arr[i]);

            freq[arr[i]]++; // Increment frequency of that element

        }



        // Print frequency of each element in order of appearance

        for (int i = 0; i < N; i++) {

            printf("%d ", freq[arr[i]]);

        }

        printf("\n"); // Next test case output on a new line

    }



    return 0;

}



125. Count Beautiful Pairs


#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n);

    int A[n];
    for (int i = 0; i < n; i++)
        scanf("%d", &A[i]);

    int count = 0;

    // O(N^2) check for all pairs
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (A[i] == A[j] * A[j]) {
                count++;
            }
        }
    }

    printf("%d\n", count);
    return 0;
}


126. Hashing Function Example


#include <stdio.h>

const int M = 999983;

int f(int x) {
    return x % M;
}

int main() {    
    for(int i = 0; i < 5; i++) {
        int x;
        scanf("%d", &x);
        printf("x = %d, f(x) = %d\n", x, f(x));
    }
    return 0;
}


127. Count Beautiful Pairs


#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Define the maximum possible value for A[i] based on constraints (10^4)
#define MAX_A_VALUE 10000 
// The frequency array size needs to be MAX_A_VALUE + 1 (for 0-based indexing up to 10000)
#define FREQ_ARRAY_SIZE (MAX_A_VALUE + 1)

/**
 * @brief Counts the number of Beautiful Pairs (i, j) such that A[i] = A[j]^2 and i < j.
 * * @param A Pointer to the array of integers.
 * @param N The size of the array A.
 * @return long long The total count of Beautiful Pairs.
 */
long long countBeautifulPairs(const int *A, int N) {
    // 1. Initialize Frequency Array (Hash Array)
    // The array is declared on the stack or globally for simplicity and efficiency,
    // as its size is small (10001).
    // Freq[x] will store the count of the integer 'x'.
    int Freq[FREQ_ARRAY_SIZE] = {0}; 
    
    long long totalBeautifulPairs = 0;
    
    // --- Step 2: Pre-populate Freq Array (O(N)) ---
    // Count the occurrences of all elements in the entire array A.
    // We only need to process elements up to MAX_A_VALUE.
    for (int k = 0; k < N; k++) {
        if (A[k] >= 1 && A[k] <= MAX_A_VALUE) {
            Freq[A[k]]++;
        }
        // Note: Elements outside the range 1..10000 can be ignored per constraints,
        // but robust code would handle or assume adherence to input specs.
    }
    
    // --- Step 3: Iterate and Count (O(N)) ---
    // We iterate through the array, using A[i] as the 'left' element (A_i).
    for (int i = 0; i < N; i++) {
        int Ai = A[i];
        
        // A. Decrement Frequency:
        // A[i] is being processed as the left element. It cannot form a pair 
        // with itself or any element before it. We remove its count from the 
        // total remaining elements (the suffix A[i+1...N]).
        if (Ai >= 1 && Ai <= MAX_A_VALUE) {
            Freq[Ai]--;
        } else {
            // Skip processing elements outside the valid range.
            continue; 
        }

        // B. Check Condition (A[i] = A[j]^2)
        // We need to find Aj such that Aj^2 = Ai.
        
        double root = sqrt((double)Ai);
        int Aj = (int)round(root); // Use round for reliable integer check
        
        // Check if Ai is a perfect square AND Aj is a valid value for A[j] (1 <= Aj <= 100)
        // Max value of Aj is sqrt(10000) = 100.
        // We only need to check the required value Aj.
        if (Aj * Aj == Ai) {
            
            // Check if the required A[j] value (Aj) is within bounds 
            // for the frequency array (1 to 10000).
            if (Aj >= 1 && Aj <= MAX_A_VALUE) {
                // Freq[Aj] gives the count of Aj in the suffix A[i+1...N].
                // This count is the number of Beautiful Pairs formed by A[i].
                totalBeautifulPairs += Freq[Aj];
            }
        }
    }
    
    return totalBeautifulPairs;
}

// --- Main function for testing ---
int main() {
    int N;
    
    // Read N
    if (scanf("%d", &N) != 1) return 1;

    // Allocate memory for array A (using malloc for large N)
    int *A = (int *)malloc(N * sizeof(int));
    if (A == NULL) return 1;

    // Read array A
    for (int i = 0; i < N; i++) {
        if (scanf("%d", &A[i]) != 1) {
            free(A);
            return 1;
        }
    }

    // Call the counting function
    long long result = countBeautifulPairs(A, N);

    // Print the result
    printf("%lld\n", result);

    // Free allocated memory
    free(A);

    return 0;
}




